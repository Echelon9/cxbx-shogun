// ******************************************************************
// *
// *    .,-:::::    .,::      .::::::::.    .,::      .:
// *  ,;;;'````'    `;;;,  .,;;  ;;;'';;'   `;;;,  .,;;
// *  [[[             '[[,,[['   [[[__[[\.    '[[,,[['
// *  $$$              Y$$$P     $$""""Y$$     Y$$$P
// *  `88bo,__,o,    oP"``"Yo,  _88o,,od8P   oP"``"Yo,
// *    "YUMMMMMP",m"       "Mm,""YUMMMP" ,m"       "Mm,
// *
// *   Cxbx->Win32->CxbxKrnl->EmuKrnl.cpp
// *
// *  This file is part of the Cxbx project.
// *
// *  Cxbx and Cxbe are free software; you can redistribute them
// *  and/or modify them under the terms of the GNU General Public
// *  License as published by the Free Software Foundation; either
// *  version 2 of the license, or (at your option) any later version.
// *
// *  This program is distributed in the hope that it will be useful,
// *  but WITHOUT ANY WARRANTY; without even the implied warranty of
// *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// *  GNU General Public License for more details.
// *
// *  You should have recieved a copy of the GNU General Public License
// *  along with this program; see the file COPYING.
// *  If not, write to the Free Software Foundation, Inc.,
// *  59 Temple Place - Suite 330, Bostom, MA 02111-1307, USA.
// *
// *  (c) 2002-2003 Aaron Robinson <caustik@caustik.com>
// *
// *  All rights reserved
// *
// ******************************************************************
#define _CXBXKRNL_INTERNAL
#define _XBOXKRNL_DEFEXTRN_

// prevent name collisions
namespace xboxkrnl
{
    #include <xboxkrnl/xboxkrnl.h>
};

#include <cstdio>
#include <cctype>
#include <clocale>
#include <process.h>

// prevent name collisions
namespace NtDll
{
    #include "EmuNtDll.h"
};

#include "CxbxKrnl.h"
#include "Emu.h"
#include "EmuFS.h"
#include "EmuFile.h"
#include "EmuAlloc.h"
#include "EmuXTL.h"
#include "ResourceTracker.h"

#pragma warning(disable:4005) // Ignore redefined status values
#include <ntstatus.h>
#pragma warning(default:4005)

// PsCreateSystemThread proxy parameters
typedef struct _PCSTProxyParam
{
    IN PVOID  StartContext1;
    IN PVOID  StartContext2;
    IN PVOID  StartRoutine;
    IN BOOL   StartSuspended;
    IN HANDLE hStartedEvent;
}
PCSTProxyParam;

// Global Variable(s)
extern PVOID g_pfnThreadNotification[16] = { NULL };
extern int g_iThreadNotificationCount = 0;
PVOID g_pPersistedData = NULL;

// A critical section containing the PC and Xbox equivalent
struct INTERNAL_CRITICAL_SECTION
{
	xboxkrnl::PRTL_CRITICAL_SECTION XboxCriticalSection;
	NtDll::_RTL_CRITICAL_SECTION NativeCriticalSection;
};

#define MAX_XBOX_CRITICAL_SECTIONS 1024
INTERNAL_CRITICAL_SECTION GlobalCriticalSections[MAX_XBOX_CRITICAL_SECTIONS] = {0};

void InitializeSectionStructures(void)
{
	ZeroMemory(GlobalCriticalSections, sizeof(GlobalCriticalSections));
}

int FindCriticalSection(xboxkrnl::PRTL_CRITICAL_SECTION CriticalSection)
{
	int FreeSection = -1;

	int iSection = 0;
	for (iSection = 0; iSection < MAX_XBOX_CRITICAL_SECTIONS; ++iSection)
	{
		if (GlobalCriticalSections[iSection].XboxCriticalSection == CriticalSection)
		{
			FreeSection = iSection;
			break;
		}
		else if (FreeSection < 0 && GlobalCriticalSections[iSection].XboxCriticalSection == NULL)
		{
			FreeSection = iSection;
		}
	}

	if (FreeSection < 0)
	{
		EmuWarning("Too many critical sections in use!\n");
	}

	return FreeSection;
}

static CHAR* NtStatusToString ( IN NTSTATUS Status )
{
    switch(Status)
    {
    case 0x00000000: return "STATUS_SUCCESS";
    case 0x00000001: return "STATUS_WAIT_1";
    case 0x00000002: return "STATUS_WAIT_2";
    case 0x00000003: return "STATUS_WAIT_3";
    case 0x0000003F: return "STATUS_WAIT_63";
    case 0x00000080: return "STATUS_ABANDONED_WAIT_0";
    case 0x000000BF: return "STATUS_ABANDONED_WAIT_63";
    case 0x000000C0: return "STATUS_USER_APC";
    case 0x00000100: return "STATUS_KERNEL_APC";
    case 0x00000101: return "STATUS_ALERTED";
    case 0x00000102: return "STATUS_TIMEOUT";
    case 0x00000103: return "STATUS_PENDING";
    case 0x00000104: return "STATUS_REPARSE";
    case 0x00000105: return "STATUS_MORE_ENTRIES";
    case 0x00000106: return "STATUS_NOT_ALL_ASSIGNED";
    case 0x00000107: return "STATUS_SOME_NOT_MAPPED";
    case 0x00000108: return "STATUS_OPLOCK_BREAK_IN_PROGRESS";
    case 0x00000109: return "STATUS_VOLUME_MOUNTED";
    case 0x0000010A: return "STATUS_RXACT_COMMITTED";
    case 0x0000010B: return "STATUS_NOTIFY_CLEANUP";
    case 0x0000010C: return "STATUS_NOTIFY_ENUM_DIR";
    case 0x0000010D: return "STATUS_NO_QUOTAS_FOR_ACCOUNT";
    case 0x0000010E: return "STATUS_PRIMARY_TRANSPORT_CONNECT_FAILED";
    case 0x00000110: return "STATUS_PAGE_FAULT_TRANSITION";
    case 0x00000111: return "STATUS_PAGE_FAULT_DEMAND_ZERO";
    case 0x00000112: return "STATUS_PAGE_FAULT_COPY_ON_WRITE";
    case 0x00000113: return "STATUS_PAGE_FAULT_GUARD_PAGE";
    case 0x00000114: return "STATUS_PAGE_FAULT_PAGING_FILE";
    case 0x00000115: return "STATUS_CACHE_PAGE_LOCKED";
    case 0x00000116: return "STATUS_CRASH_DUMP";
    case 0x00000117: return "STATUS_BUFFER_ALL_ZEROS";
    case 0x00000118: return "STATUS_REPARSE_OBJECT";
    case 0x00000119: return "STATUS_RESOURCE_REQUIREMENTS_CHANGED";
    case 0x00000120: return "STATUS_TRANSLATION_COMPLETE";
    case 0x00000121: return "STATUS_DS_MEMBERSHIP_EVALUATED_LOCALLY";
    case 0x00010001: return "DBG_EXCEPTION_HANDLED";
    case 0x00010002: return "DBG_CONTINUE";
    case 0x40000000: return "STATUS_OBJECT_NAME_EXISTS";
    case 0x40000001: return "STATUS_THREAD_WAS_SUSPENDED";
    case 0x40000002: return "STATUS_WORKING_SET_LIMIT_RANGE";
    case 0x40000003: return "STATUS_IMAGE_NOT_AT_BASE";
    case 0x40000004: return "STATUS_RXACT_STATE_CREATED";
    case 0x40000005: return "STATUS_SEGMENT_NOTIFICATION";
    case 0x40000006: return "STATUS_LOCAL_USER_SESSION_KEY";
    case 0x40000007: return "STATUS_BAD_CURRENT_DIRECTORY";
    case 0x40000008: return "STATUS_SERIAL_MORE_WRITES";
    case 0x40000009: return "STATUS_REGISTRY_RECOVERED";
    case 0x4000000A: return "STATUS_FT_READ_RECOVERY_FROM_BACKUP";
    case 0x4000000B: return "STATUS_FT_WRITE_RECOVERY";
    case 0x4000000C: return "STATUS_SERIAL_COUNTER_TIMEOUT";
    case 0x4000000D: return "STATUS_NULL_LM_PASSWORD";
    case 0x4000000E: return "STATUS_IMAGE_MACHINE_TYPE_MISMATCH";
    case 0x4000000F: return "STATUS_RECEIVE_PARTIAL";
    case 0x40000010: return "STATUS_RECEIVE_EXPEDITED";
    case 0x40000011: return "STATUS_RECEIVE_PARTIAL_EXPEDITED";
    case 0x40000012: return "STATUS_EVENT_DONE";
    case 0x40000013: return "STATUS_EVENT_PENDING";
    case 0x40000014: return "STATUS_CHECKING_FILE_SYSTEM";
    case 0x40000015: return "STATUS_FATAL_APP_EXIT";
    case 0x40000016: return "STATUS_PREDEFINED_HANDLE";
    case 0x40000017: return "STATUS_WAS_UNLOCKED";
    case 0x40000018: return "STATUS_SERVICE_NOTIFICATION";
    case 0x40000019: return "STATUS_WAS_LOCKED";
    case 0x4000001A: return "STATUS_LOG_HARD_ERROR";
    case 0x4000001B: return "STATUS_ALREADY_WIN32";
    case 0x4000001C: return "STATUS_WX86_UNSIMULATE";
    case 0x4000001D: return "STATUS_WX86_CONTINUE";
    case 0x4000001E: return "STATUS_WX86_SINGLE_STEP";
    case 0x4000001F: return "STATUS_WX86_BREAKPOINT";
    case 0x40000020: return "STATUS_WX86_EXCEPTION_CONTINUE";
    case 0x40000021: return "STATUS_WX86_EXCEPTION_LASTCHANCE";
    case 0x40000022: return "STATUS_WX86_EXCEPTION_CHAIN";
    case 0x40000023: return "STATUS_IMAGE_MACHINE_TYPE_MISMATCH_EXE";
    case 0x40000024: return "STATUS_NO_YIELD_PERFORMED";
    case 0x40000025: return "STATUS_TIMER_RESUME_IGNORED";
    case 0x40000026: return "STATUS_ARBITRATION_UNHANDLED";
    case 0x40000027: return "STATUS_CARDBUS_NOT_SUPPORTED";
    case 0x40000028: return "STATUS_WX86_CREATEWX86TIB";
    case 0x40000029: return "STATUS_MP_PROCESSOR_MISMATCH";
    case 0x40010001: return "DBG_REPLY_LATER";
    case 0x40010002: return "DBG_UNABLE_TO_PROVIDE_HANDLE";
    case 0x40010003: return "DBG_TERMINATE_THREAD";
    case 0x40010004: return "DBG_TERMINATE_PROCESS";
    case 0x40010005: return "DBG_CONTROL_C";
    case 0x40010006: return "DBG_PRINTEXCEPTION_C";
    case 0x40010007: return "DBG_RIPEXCEPTION";
    case 0x40010008: return "DBG_CONTROL_BREAK";
    case 0x80000001: return "STATUS_GUARD_PAGE_VIOLATION";
    case 0x80000002: return "STATUS_DATATYPE_MISALIGNMENT";
    case 0x80000003: return "STATUS_BREAKPOINT";
    case 0x80000004: return "STATUS_SINGLE_STEP";
    case 0x80000005: return "STATUS_BUFFER_OVERFLOW";
    case 0x80000006: return "STATUS_NO_MORE_FILES";
    case 0x80000007: return "STATUS_WAKE_SYSTEM_DEBUGGER";
    case 0x8000000A: return "STATUS_HANDLES_CLOSED";
    case 0x8000000B: return "STATUS_NO_INHERITANCE";
    case 0x8000000C: return "STATUS_GUID_SUBSTITUTION_MADE";
    case 0x8000000D: return "STATUS_PARTIAL_COPY";
    case 0x8000000E: return "STATUS_DEVICE_PAPER_EMPTY";
    case 0x8000000F: return "STATUS_DEVICE_POWERED_OFF";
    case 0x80000010: return "STATUS_DEVICE_OFF_LINE";
    case 0x80000011: return "STATUS_DEVICE_BUSY";
    case 0x80000012: return "STATUS_NO_MORE_EAS";
    case 0x80000013: return "STATUS_INVALID_EA_NAME";
    case 0x80000014: return "STATUS_EA_LIST_INCONSISTENT";
    case 0x80000015: return "STATUS_INVALID_EA_FLAG";
    case 0x80000016: return "STATUS_VERIFY_REQUIRED";
    case 0x80000017: return "STATUS_EXTRANEOUS_INFORMATION";
    case 0x80000018: return "STATUS_RXACT_COMMIT_NECESSARY";
    case 0x8000001A: return "STATUS_NO_MORE_ENTRIES";
    case 0x8000001B: return "STATUS_FILEMARK_DETECTED";
    case 0x8000001C: return "STATUS_MEDIA_CHANGED";
    case 0x8000001D: return "STATUS_BUS_RESET";
    case 0x8000001E: return "STATUS_END_OF_MEDIA";
    case 0x8000001F: return "STATUS_BEGINNING_OF_MEDIA";
    case 0x80000020: return "STATUS_MEDIA_CHECK";
    case 0x80000021: return "STATUS_SETMARK_DETECTED";
    case 0x80000022: return "STATUS_NO_DATA_DETECTED";
    case 0x80000023: return "STATUS_REDIRECTOR_HAS_OPEN_HANDLES";
    case 0x80000024: return "STATUS_SERVER_HAS_OPEN_HANDLES";
    case 0x80000025: return "STATUS_ALREADY_DISCONNECTED";
    case 0x80000026: return "STATUS_LONGJUMP";
    case 0x80010001: return "DBG_EXCEPTION_NOT_HANDLED";
    case 0xC0000001: return "STATUS_UNSUCCESSFUL";
    case 0xC0000002: return "STATUS_NOT_IMPLEMENTED";
    case 0xC0000003: return "STATUS_INVALID_INFO_CLASS";
    case 0xC0000004: return "STATUS_INFO_LENGTH_MISMATCH";
    case 0xC0000005: return "STATUS_ACCESS_VIOLATION";
    case 0xC0000006: return "STATUS_IN_PAGE_ERROR";
    case 0xC0000007: return "STATUS_PAGEFILE_QUOTA";
    case 0xC0000008: return "STATUS_INVALID_HANDLE";
    case 0xC0000009: return "STATUS_BAD_INITIAL_STACK";
    case 0xC000000A: return "STATUS_BAD_INITIAL_PC";
    case 0xC000000B: return "STATUS_INVALID_CID";
    case 0xC000000C: return "STATUS_TIMER_NOT_CANCELED";
    case 0xC000000D: return "STATUS_INVALID_PARAMETER";
    case 0xC000000E: return "STATUS_NO_SUCH_DEVICE";
    case 0xC000000F: return "STATUS_NO_SUCH_FILE";
    case 0xC0000010: return "STATUS_INVALID_DEVICE_REQUEST";
    case 0xC0000011: return "STATUS_END_OF_FILE";
    case 0xC0000012: return "STATUS_WRONG_VOLUME";
    case 0xC0000013: return "STATUS_NO_MEDIA_IN_DEVICE";
    case 0xC0000014: return "STATUS_UNRECOGNIZED_MEDIA";
    case 0xC0000015: return "STATUS_NONEXISTENT_SECTOR";
    case 0xC0000016: return "STATUS_MORE_PROCESSING_REQUIRED";
    case 0xC0000017: return "STATUS_NO_MEMORY";
    case 0xC0000018: return "STATUS_CONFLICTING_ADDRESSES";
    case 0xC0000019: return "STATUS_NOT_MAPPED_VIEW";
    case 0xC000001A: return "STATUS_UNABLE_TO_FREE_VM";
    case 0xC000001B: return "STATUS_UNABLE_TO_DELETE_SECTION";
    case 0xC000001C: return "STATUS_INVALID_SYSTEM_SERVICE";
    case 0xC000001D: return "STATUS_ILLEGAL_INSTRUCTION";
    case 0xC000001E: return "STATUS_INVALID_LOCK_SEQUENCE";
    case 0xC000001F: return "STATUS_INVALID_VIEW_SIZE";
    case 0xC0000020: return "STATUS_INVALID_FILE_FOR_SECTION";
    case 0xC0000021: return "STATUS_ALREADY_COMMITTED";
    case 0xC0000022: return "STATUS_ACCESS_DENIED";
    case 0xC0000023: return "STATUS_BUFFER_TOO_SMALL";
    case 0xC0000024: return "STATUS_OBJECT_TYPE_MISMATCH";
    case 0xC0000025: return "STATUS_NONCONTINUABLE_EXCEPTION";
    case 0xC0000026: return "STATUS_INVALID_DISPOSITION";
    case 0xC0000027: return "STATUS_UNWIND";
    case 0xC0000028: return "STATUS_BAD_STACK";
    case 0xC0000029: return "STATUS_INVALID_UNWIND_TARGET";
    case 0xC000002A: return "STATUS_NOT_LOCKED";
    case 0xC000002B: return "STATUS_PARITY_ERROR";
    case 0xC000002C: return "STATUS_UNABLE_TO_DECOMMIT_VM";
    case 0xC000002D: return "STATUS_NOT_COMMITTED";
    case 0xC000002E: return "STATUS_INVALID_PORT_ATTRIBUTES";
    case 0xC000002F: return "STATUS_PORT_MESSAGE_TOO_LONG";
    case 0xC0000030: return "STATUS_INVALID_PARAMETER_MIX";
    case 0xC0000031: return "STATUS_INVALID_QUOTA_LOWER";
    case 0xC0000032: return "STATUS_DISK_CORRUPT_ERROR";
    case 0xC0000033: return "STATUS_OBJECT_NAME_INVALID";
    case 0xC0000034: return "STATUS_OBJECT_NAME_NOT_FOUND";
    case 0xC0000035: return "STATUS_OBJECT_NAME_COLLISION";
    case 0xC0000037: return "STATUS_PORT_DISCONNECTED";
    case 0xC0000038: return "STATUS_DEVICE_ALREADY_ATTACHED";
    case 0xC0000039: return "STATUS_OBJECT_PATH_INVALID";
    case 0xC000003A: return "STATUS_OBJECT_PATH_NOT_FOUND";
    case 0xC000003B: return "STATUS_OBJECT_PATH_SYNTAX_BAD";
    case 0xC000003C: return "STATUS_DATA_OVERRUN";
    case 0xC000003D: return "STATUS_DATA_LATE_ERROR";
    case 0xC000003E: return "STATUS_DATA_ERROR";
    case 0xC000003F: return "STATUS_CRC_ERROR";
    case 0xC0000040: return "STATUS_SECTION_TOO_BIG";
    case 0xC0000041: return "STATUS_PORT_CONNECTION_REFUSED";
    case 0xC0000042: return "STATUS_INVALID_PORT_HANDLE";
    case 0xC0000043: return "STATUS_SHARING_VIOLATION";
    case 0xC0000044: return "STATUS_QUOTA_EXCEEDED";
    case 0xC0000045: return "STATUS_INVALID_PAGE_PROTECTION";
    case 0xC0000046: return "STATUS_MUTANT_NOT_OWNED";
    case 0xC0000047: return "STATUS_SEMAPHORE_LIMIT_EXCEEDED";
    case 0xC0000048: return "STATUS_PORT_ALREADY_SET";
    case 0xC0000049: return "STATUS_SECTION_NOT_IMAGE";
    case 0xC000004A: return "STATUS_SUSPEND_COUNT_EXCEEDED";
    case 0xC000004B: return "STATUS_THREAD_IS_TERMINATING";
    case 0xC000004C: return "STATUS_BAD_WORKING_SET_LIMIT";
    case 0xC000004D: return "STATUS_INCOMPATIBLE_FILE_MAP";
    case 0xC000004E: return "STATUS_SECTION_PROTECTION";
    case 0xC000004F: return "STATUS_EAS_NOT_SUPPORTED";
    case 0xC0000050: return "STATUS_EA_TOO_LARGE";
    case 0xC0000051: return "STATUS_NONEXISTENT_EA_ENTRY";
    case 0xC0000052: return "STATUS_NO_EAS_ON_FILE";
    case 0xC0000053: return "STATUS_EA_CORRUPT_ERROR";
    case 0xC0000054: return "STATUS_FILE_LOCK_CONFLICT";
    case 0xC0000055: return "STATUS_LOCK_NOT_GRANTED";
    case 0xC0000056: return "STATUS_DELETE_PENDING";
    case 0xC0000057: return "STATUS_CTL_FILE_NOT_SUPPORTED";
    case 0xC0000058: return "STATUS_UNKNOWN_REVISION";
    case 0xC0000059: return "STATUS_REVISION_MISMATCH";
    case 0xC000005A: return "STATUS_INVALID_OWNER";
    case 0xC000005B: return "STATUS_INVALID_PRIMARY_GROUP";
    case 0xC000005C: return "STATUS_NO_IMPERSONATION_TOKEN";
    case 0xC000005D: return "STATUS_CANT_DISABLE_MANDATORY";
    case 0xC000005E: return "STATUS_NO_LOGON_SERVERS";
    case 0xC000005F: return "STATUS_NO_SUCH_LOGON_SESSION";
    case 0xC0000060: return "STATUS_NO_SUCH_PRIVILEGE";
    case 0xC0000061: return "STATUS_PRIVILEGE_NOT_HELD";
    case 0xC0000062: return "STATUS_INVALID_ACCOUNT_NAME";
    case 0xC0000063: return "STATUS_USER_EXISTS";
    case 0xC0000064: return "STATUS_NO_SUCH_USER";
    case 0xC0000065: return "STATUS_GROUP_EXISTS";
    case 0xC0000066: return "STATUS_NO_SUCH_GROUP";
    case 0xC0000067: return "STATUS_MEMBER_IN_GROUP";
    case 0xC0000068: return "STATUS_MEMBER_NOT_IN_GROUP";
    case 0xC0000069: return "STATUS_LAST_ADMIN";
    case 0xC000006A: return "STATUS_WRONG_PASSWORD";
    case 0xC000006B: return "STATUS_ILL_FORMED_PASSWORD";
    case 0xC000006C: return "STATUS_PASSWORD_RESTRICTION";
    case 0xC000006D: return "STATUS_LOGON_FAILURE";
    case 0xC000006E: return "STATUS_ACCOUNT_RESTRICTION";
    case 0xC000006F: return "STATUS_INVALID_LOGON_HOURS";
    case 0xC0000070: return "STATUS_INVALID_WORKSTATION";
    case 0xC0000071: return "STATUS_PASSWORD_EXPIRED";
    case 0xC0000072: return "STATUS_ACCOUNT_DISABLED";
    case 0xC0000073: return "STATUS_NONE_MAPPED";
    case 0xC0000074: return "STATUS_TOO_MANY_LUIDS_REQUESTED";
    case 0xC0000075: return "STATUS_LUIDS_EXHAUSTED";
    case 0xC0000076: return "STATUS_INVALID_SUB_AUTHORITY";
    case 0xC0000077: return "STATUS_INVALID_ACL";
    case 0xC0000078: return "STATUS_INVALID_SID";
    case 0xC0000079: return "STATUS_INVALID_SECURITY_DESCR";
    case 0xC000007A: return "STATUS_PROCEDURE_NOT_FOUND";
    case 0xC000007B: return "STATUS_INVALID_IMAGE_FORMAT";
    case 0xC000007C: return "STATUS_NO_TOKEN";
    case 0xC000007D: return "STATUS_BAD_INHERITANCE_ACL";
    case 0xC000007E: return "STATUS_RANGE_NOT_LOCKED";
    case 0xC000007F: return "STATUS_DISK_FULL";
    case 0xC0000080: return "STATUS_SERVER_DISABLED";
    case 0xC0000081: return "STATUS_SERVER_NOT_DISABLED";
    case 0xC0000082: return "STATUS_TOO_MANY_GUIDS_REQUESTED";
    case 0xC0000083: return "STATUS_GUIDS_EXHAUSTED";
    case 0xC0000084: return "STATUS_INVALID_ID_AUTHORITY";
    case 0xC0000085: return "STATUS_AGENTS_EXHAUSTED";
    case 0xC0000086: return "STATUS_INVALID_VOLUME_LABEL";
    case 0xC0000087: return "STATUS_SECTION_NOT_EXTENDED";
    case 0xC0000088: return "STATUS_NOT_MAPPED_DATA";
    case 0xC0000089: return "STATUS_RESOURCE_DATA_NOT_FOUND";
    case 0xC000008A: return "STATUS_RESOURCE_TYPE_NOT_FOUND";
    case 0xC000008B: return "STATUS_RESOURCE_NAME_NOT_FOUND";
    case 0xC000008C: return "STATUS_ARRAY_BOUNDS_EXCEEDED";
    case 0xC000008D: return "STATUS_FLOAT_DENORMAL_OPERAND";
    case 0xC000008E: return "STATUS_FLOAT_DIVIDE_BY_ZERO";
    case 0xC000008F: return "STATUS_FLOAT_INEXACT_RESULT";
    case 0xC0000090: return "STATUS_FLOAT_INVALID_OPERATION";
    case 0xC0000091: return "STATUS_FLOAT_OVERFLOW";
    case 0xC0000092: return "STATUS_FLOAT_STACK_CHECK";
    case 0xC0000093: return "STATUS_FLOAT_UNDERFLOW";
    case 0xC0000094: return "STATUS_INTEGER_DIVIDE_BY_ZERO";
    case 0xC0000095: return "STATUS_INTEGER_OVERFLOW";
    case 0xC0000096: return "STATUS_PRIVILEGED_INSTRUCTION";
    case 0xC0000097: return "STATUS_TOO_MANY_PAGING_FILES";
    case 0xC0000098: return "STATUS_FILE_INVALID";
    case 0xC0000099: return "STATUS_ALLOTTED_SPACE_EXCEEDED";
    case 0xC000009A: return "STATUS_INSUFFICIENT_RESOURCES";
    case 0xC000009B: return "STATUS_DFS_EXIT_PATH_FOUND";
    case 0xC000009C: return "STATUS_DEVICE_DATA_ERROR";
    case 0xC000009D: return "STATUS_DEVICE_NOT_CONNECTED";
    case 0xC000009E: return "STATUS_DEVICE_POWER_FAILURE";
    case 0xC000009F: return "STATUS_FREE_VM_NOT_AT_BASE";
    case 0xC00000A0: return "STATUS_MEMORY_NOT_ALLOCATED";
    case 0xC00000A1: return "STATUS_WORKING_SET_QUOTA";
    case 0xC00000A2: return "STATUS_MEDIA_WRITE_PROTECTED";
    case 0xC00000A3: return "STATUS_DEVICE_NOT_READY";
    case 0xC00000A4: return "STATUS_INVALID_GROUP_ATTRIBUTES";
    case 0xC00000A5: return "STATUS_BAD_IMPERSONATION_LEVEL";
    case 0xC00000A6: return "STATUS_CANT_OPEN_ANONYMOUS";
    case 0xC00000A7: return "STATUS_BAD_VALIDATION_CLASS";
    case 0xC00000A8: return "STATUS_BAD_TOKEN_TYPE";
    case 0xC00000A9: return "STATUS_BAD_MASTER_BOOT_RECORD";
    case 0xC00000AA: return "STATUS_INSTRUCTION_MISALIGNMENT";
    case 0xC00000AB: return "STATUS_INSTANCE_NOT_AVAILABLE";
    case 0xC00000AC: return "STATUS_PIPE_NOT_AVAILABLE";
    case 0xC00000AD: return "STATUS_INVALID_PIPE_STATE";
    case 0xC00000AE: return "STATUS_PIPE_BUSY";
    case 0xC00000AF: return "STATUS_ILLEGAL_FUNCTION";
    case 0xC00000B0: return "STATUS_PIPE_DISCONNECTED";
    case 0xC00000B1: return "STATUS_PIPE_CLOSING";
    case 0xC00000B2: return "STATUS_PIPE_CONNECTED";
    case 0xC00000B3: return "STATUS_PIPE_LISTENING";
    case 0xC00000B4: return "STATUS_INVALID_READ_MODE";
    case 0xC00000B5: return "STATUS_IO_TIMEOUT";
    case 0xC00000B6: return "STATUS_FILE_FORCED_CLOSED";
    case 0xC00000B7: return "STATUS_PROFILING_NOT_STARTED";
    case 0xC00000B8: return "STATUS_PROFILING_NOT_STOPPED";
    case 0xC00000B9: return "STATUS_COULD_NOT_INTERPRET";
    case 0xC00000BA: return "STATUS_FILE_IS_A_DIRECTORY";
    case 0xC00000BB: return "STATUS_NOT_SUPPORTED";
    case 0xC00000BC: return "STATUS_REMOTE_NOT_LISTENING";
    case 0xC00000BD: return "STATUS_DUPLICATE_NAME";
    case 0xC00000BE: return "STATUS_BAD_NETWORK_PATH";
    case 0xC00000BF: return "STATUS_NETWORK_BUSY";
    case 0xC00000C0: return "STATUS_DEVICE_DOES_NOT_EXIST";
    case 0xC00000C1: return "STATUS_TOO_MANY_COMMANDS";
    case 0xC00000C2: return "STATUS_ADAPTER_HARDWARE_ERROR";
    case 0xC00000C3: return "STATUS_INVALID_NETWORK_RESPONSE";
    case 0xC00000C4: return "STATUS_UNEXPECTED_NETWORK_ERROR";
    case 0xC00000C5: return "STATUS_BAD_REMOTE_ADAPTER";
    case 0xC00000C6: return "STATUS_PRINT_QUEUE_FULL";
    case 0xC00000C7: return "STATUS_NO_SPOOL_SPACE";
    case 0xC00000C8: return "STATUS_PRINT_CANCELLED";
    case 0xC00000C9: return "STATUS_NETWORK_NAME_DELETED";
    case 0xC00000CA: return "STATUS_NETWORK_ACCESS_DENIED";
    case 0xC00000CB: return "STATUS_BAD_DEVICE_TYPE";
    case 0xC00000CC: return "STATUS_BAD_NETWORK_NAME";
    case 0xC00000CD: return "STATUS_TOO_MANY_NAMES";
    case 0xC00000CE: return "STATUS_TOO_MANY_SESSIONS";
    case 0xC00000CF: return "STATUS_SHARING_PAUSED";
    case 0xC00000D0: return "STATUS_REQUEST_NOT_ACCEPTED";
    case 0xC00000D1: return "STATUS_REDIRECTOR_PAUSED";
    case 0xC00000D2: return "STATUS_NET_WRITE_FAULT";
    case 0xC00000D3: return "STATUS_PROFILING_AT_LIMIT";
    case 0xC00000D4: return "STATUS_NOT_SAME_DEVICE";
    case 0xC00000D5: return "STATUS_FILE_RENAMED";
    case 0xC00000D6: return "STATUS_VIRTUAL_CIRCUIT_CLOSED";
    case 0xC00000D7: return "STATUS_NO_SECURITY_ON_OBJECT";
    case 0xC00000D8: return "STATUS_CANT_WAIT";
    case 0xC00000D9: return "STATUS_PIPE_EMPTY";
    case 0xC00000DA: return "STATUS_CANT_ACCESS_DOMAIN_INFO";
    case 0xC00000DB: return "STATUS_CANT_TERMINATE_SELF";
    case 0xC00000DC: return "STATUS_INVALID_SERVER_STATE";
    case 0xC00000DD: return "STATUS_INVALID_DOMAIN_STATE";
    case 0xC00000DE: return "STATUS_INVALID_DOMAIN_ROLE";
    case 0xC00000DF: return "STATUS_NO_SUCH_DOMAIN";
    case 0xC00000E0: return "STATUS_DOMAIN_EXISTS";
    case 0xC00000E1: return "STATUS_DOMAIN_LIMIT_EXCEEDED";
    case 0xC00000E2: return "STATUS_OPLOCK_NOT_GRANTED";
    case 0xC00000E3: return "STATUS_INVALID_OPLOCK_PROTOCOL";
    case 0xC00000E4: return "STATUS_INTERNAL_DB_CORRUPTION";
    case 0xC00000E5: return "STATUS_INTERNAL_ERROR";
    case 0xC00000E6: return "STATUS_GENERIC_NOT_MAPPED";
    case 0xC00000E7: return "STATUS_BAD_DESCRIPTOR_FORMAT";
    case 0xC00000E8: return "STATUS_INVALID_USER_BUFFER";
    case 0xC00000E9: return "STATUS_UNEXPECTED_IO_ERROR";
    case 0xC00000EA: return "STATUS_UNEXPECTED_MM_CREATE_ERR";
    case 0xC00000EB: return "STATUS_UNEXPECTED_MM_MAP_ERROR";
    case 0xC00000EC: return "STATUS_UNEXPECTED_MM_EXTEND_ERR";
    case 0xC00000ED: return "STATUS_NOT_LOGON_PROCESS";
    case 0xC00000EE: return "STATUS_LOGON_SESSION_EXISTS";
    case 0xC00000EF: return "STATUS_INVALID_PARAMETER_1";
    case 0xC00000F0: return "STATUS_INVALID_PARAMETER_2";
    case 0xC00000F1: return "STATUS_INVALID_PARAMETER_3";
    case 0xC00000F2: return "STATUS_INVALID_PARAMETER_4";
    case 0xC00000F3: return "STATUS_INVALID_PARAMETER_5";
    case 0xC00000F4: return "STATUS_INVALID_PARAMETER_6";
    case 0xC00000F5: return "STATUS_INVALID_PARAMETER_7";
    case 0xC00000F6: return "STATUS_INVALID_PARAMETER_8";
    case 0xC00000F7: return "STATUS_INVALID_PARAMETER_9";
    case 0xC00000F8: return "STATUS_INVALID_PARAMETER_10";
    case 0xC00000F9: return "STATUS_INVALID_PARAMETER_11";
    case 0xC00000FA: return "STATUS_INVALID_PARAMETER_12";
    case 0xC00000FB: return "STATUS_REDIRECTOR_NOT_STARTED";
    case 0xC00000FC: return "STATUS_REDIRECTOR_STARTED";
    case 0xC00000FD: return "STATUS_STACK_OVERFLOW";
    case 0xC00000FE: return "STATUS_NO_SUCH_PACKAGE";
    case 0xC00000FF: return "STATUS_BAD_FUNCTION_TABLE";
    case 0xC0000100: return "STATUS_VARIABLE_NOT_FOUND";
    case 0xC0000101: return "STATUS_DIRECTORY_NOT_EMPTY";
    case 0xC0000102: return "STATUS_FILE_CORRUPT_ERROR";
    case 0xC0000103: return "STATUS_NOT_A_DIRECTORY";
    case 0xC0000104: return "STATUS_BAD_LOGON_SESSION_STATE";
    case 0xC0000105: return "STATUS_LOGON_SESSION_COLLISION";
    case 0xC0000106: return "STATUS_NAME_TOO_LONG";
    case 0xC0000107: return "STATUS_FILES_OPEN";
    case 0xC0000108: return "STATUS_CONNECTION_IN_USE";
    case 0xC0000109: return "STATUS_MESSAGE_NOT_FOUND";
    case 0xC000010A: return "STATUS_PROCESS_IS_TERMINATING";
    case 0xC000010B: return "STATUS_INVALID_LOGON_TYPE";
    case 0xC000010C: return "STATUS_NO_GUID_TRANSLATION";
    case 0xC000010D: return "STATUS_CANNOT_IMPERSONATE";
    case 0xC000010E: return "STATUS_IMAGE_ALREADY_LOADED";
    case 0xC000010F: return "STATUS_ABIOS_NOT_PRESENT";
    case 0xC0000110: return "STATUS_ABIOS_LID_NOT_EXIST";
    case 0xC0000111: return "STATUS_ABIOS_LID_ALREADY_OWNED";
    case 0xC0000112: return "STATUS_ABIOS_NOT_LID_OWNER";
    case 0xC0000113: return "STATUS_ABIOS_INVALID_COMMAND";
    case 0xC0000114: return "STATUS_ABIOS_INVALID_LID";
    case 0xC0000115: return "STATUS_ABIOS_SELECTOR_NOT_AVAILABLE";
    case 0xC0000116: return "STATUS_ABIOS_INVALID_SELECTOR";
    case 0xC0000117: return "STATUS_NO_LDT";
    case 0xC0000118: return "STATUS_INVALID_LDT_SIZE";
    case 0xC0000119: return "STATUS_INVALID_LDT_OFFSET";
    case 0xC000011A: return "STATUS_INVALID_LDT_DESCRIPTOR";
    case 0xC000011B: return "STATUS_INVALID_IMAGE_NE_FORMAT";
    case 0xC000011C: return "STATUS_RXACT_INVALID_STATE";
    case 0xC000011D: return "STATUS_RXACT_COMMIT_FAILURE";
    case 0xC000011E: return "STATUS_MAPPED_FILE_SIZE_ZERO";
    case 0xC000011F: return "STATUS_TOO_MANY_OPENED_FILES";
    case 0xC0000120: return "STATUS_CANCELLED";
    case 0xC0000121: return "STATUS_CANNOT_DELETE";
    case 0xC0000122: return "STATUS_INVALID_COMPUTER_NAME";
    case 0xC0000123: return "STATUS_FILE_DELETED";
    case 0xC0000124: return "STATUS_SPECIAL_ACCOUNT";
    case 0xC0000125: return "STATUS_SPECIAL_GROUP";
    case 0xC0000126: return "STATUS_SPECIAL_USER";
    case 0xC0000127: return "STATUS_MEMBERS_PRIMARY_GROUP";
    case 0xC0000128: return "STATUS_FILE_CLOSED";
    case 0xC0000129: return "STATUS_TOO_MANY_THREADS";
    case 0xC000012A: return "STATUS_THREAD_NOT_IN_PROCESS";
    case 0xC000012B: return "STATUS_TOKEN_ALREADY_IN_USE";
    case 0xC000012C: return "STATUS_PAGEFILE_QUOTA_EXCEEDED";
    case 0xC000012D: return "STATUS_COMMITMENT_LIMIT";
    case 0xC000012E: return "STATUS_INVALID_IMAGE_LE_FORMAT";
    case 0xC000012F: return "STATUS_INVALID_IMAGE_NOT_MZ";
    case 0xC0000130: return "STATUS_INVALID_IMAGE_PROTECT";
    case 0xC0000131: return "STATUS_INVALID_IMAGE_WIN_16";
    case 0xC0000132: return "STATUS_LOGON_SERVER_CONFLICT";
    case 0xC0000133: return "STATUS_TIME_DIFFERENCE_AT_DC";
    case 0xC0000134: return "STATUS_SYNCHRONIZATION_REQUIRED";
    case 0xC0000135: return "STATUS_DLL_NOT_FOUND";
    case 0xC0000136: return "STATUS_OPEN_FAILED";
    case 0xC0000137: return "STATUS_IO_PRIVILEGE_FAILED";
    case 0xC0000138: return "STATUS_ORDINAL_NOT_FOUND";
    case 0xC0000139: return "STATUS_ENTRYPOINT_NOT_FOUND";
    case 0xC000013A: return "STATUS_CONTROL_C_EXIT";
    case 0xC000013B: return "STATUS_LOCAL_DISCONNECT";
    case 0xC000013C: return "STATUS_REMOTE_DISCONNECT";
    case 0xC000013D: return "STATUS_REMOTE_RESOURCES";
    case 0xC000013E: return "STATUS_LINK_FAILED";
    case 0xC000013F: return "STATUS_LINK_TIMEOUT";
    case 0xC0000140: return "STATUS_INVALID_CONNECTION";
    case 0xC0000141: return "STATUS_INVALID_ADDRESS";
    case 0xC0000142: return "STATUS_DLL_INIT_FAILED";
    case 0xC0000143: return "STATUS_MISSING_SYSTEMFILE";
    case 0xC0000144: return "STATUS_UNHANDLED_EXCEPTION";
    case 0xC0000145: return "STATUS_APP_INIT_FAILURE";
    case 0xC0000146: return "STATUS_PAGEFILE_CREATE_FAILED";
    case 0xC0000147: return "STATUS_NO_PAGEFILE";
    case 0xC0000148: return "STATUS_INVALID_LEVEL";
    case 0xC0000149: return "STATUS_WRONG_PASSWORD_CORE";
    case 0xC000014A: return "STATUS_ILLEGAL_FLOAT_CONTEXT";
    case 0xC000014B: return "STATUS_PIPE_BROKEN";
    case 0xC000014C: return "STATUS_REGISTRY_CORRUPT";
    case 0xC000014D: return "STATUS_REGISTRY_IO_FAILED";
    case 0xC000014E: return "STATUS_NO_EVENT_PAIR";
    case 0xC000014F: return "STATUS_UNRECOGNIZED_VOLUME";
    case 0xC0000150: return "STATUS_SERIAL_NO_DEVICE_INITED";
    case 0xC0000151: return "STATUS_NO_SUCH_ALIAS";
    case 0xC0000152: return "STATUS_MEMBER_NOT_IN_ALIAS";
    case 0xC0000153: return "STATUS_MEMBER_IN_ALIAS";
    case 0xC0000154: return "STATUS_ALIAS_EXISTS";
    case 0xC0000155: return "STATUS_LOGON_NOT_GRANTED";
    case 0xC0000156: return "STATUS_TOO_MANY_SECRETS";
    case 0xC0000157: return "STATUS_SECRET_TOO_LONG";
    case 0xC0000158: return "STATUS_INTERNAL_DB_ERROR";
    case 0xC0000159: return "STATUS_FULLSCREEN_MODE";
    case 0xC000015A: return "STATUS_TOO_MANY_CONTEXT_IDS";
    case 0xC000015B: return "STATUS_LOGON_TYPE_NOT_GRANTED";
    case 0xC000015C: return "STATUS_NOT_REGISTRY_FILE";
    case 0xC000015D: return "STATUS_NT_CROSS_ENCRYPTION_REQUIRED";
    case 0xC000015E: return "STATUS_DOMAIN_CTRLR_CONFIG_ERROR";
    case 0xC000015F: return "STATUS_FT_MISSING_MEMBER";
    case 0xC0000160: return "STATUS_ILL_FORMED_SERVICE_ENTRY";
    case 0xC0000161: return "STATUS_ILLEGAL_CHARACTER";
    case 0xC0000162: return "STATUS_UNMAPPABLE_CHARACTER";
    case 0xC0000163: return "STATUS_UNDEFINED_CHARACTER";
    case 0xC0000164: return "STATUS_FLOPPY_VOLUME";
    case 0xC0000165: return "STATUS_FLOPPY_ID_MARK_NOT_FOUND";
    case 0xC0000166: return "STATUS_FLOPPY_WRONG_CYLINDER";
    case 0xC0000167: return "STATUS_FLOPPY_UNKNOWN_ERROR";
    case 0xC0000168: return "STATUS_FLOPPY_BAD_REGISTERS";
    case 0xC0000169: return "STATUS_DISK_RECALIBRATE_FAILED";
    case 0xC000016A: return "STATUS_DISK_OPERATION_FAILED";
    case 0xC000016B: return "STATUS_DISK_RESET_FAILED";
    case 0xC000016C: return "STATUS_SHARED_IRQ_BUSY";
    case 0xC000016D: return "STATUS_FT_ORPHANING";
    case 0xC000016E: return "STATUS_BIOS_FAILED_TO_CONNECT_INTERRUPT";
    case 0xC0000172: return "STATUS_PARTITION_FAILURE";
    case 0xC0000173: return "STATUS_INVALID_BLOCK_LENGTH";
    case 0xC0000174: return "STATUS_DEVICE_NOT_PARTITIONED";
    case 0xC0000175: return "STATUS_UNABLE_TO_LOCK_MEDIA";
    case 0xC0000176: return "STATUS_UNABLE_TO_UNLOAD_MEDIA";
    case 0xC0000177: return "STATUS_EOM_OVERFLOW";
    case 0xC0000178: return "STATUS_NO_MEDIA";
    case 0xC000017A: return "STATUS_NO_SUCH_MEMBER";
    case 0xC000017B: return "STATUS_INVALID_MEMBER";
    case 0xC000017C: return "STATUS_KEY_DELETED";
    case 0xC000017D: return "STATUS_NO_LOG_SPACE";
    case 0xC000017E: return "STATUS_TOO_MANY_SIDS";
    case 0xC000017F: return "STATUS_LM_CROSS_ENCRYPTION_REQUIRED";
    case 0xC0000180: return "STATUS_KEY_HAS_CHILDREN";
    case 0xC0000181: return "STATUS_CHILD_MUST_BE_VOLATILE";
    case 0xC0000182: return "STATUS_DEVICE_CONFIGURATION_ERROR";
    case 0xC0000183: return "STATUS_DRIVER_INTERNAL_ERROR";
    case 0xC0000184: return "STATUS_INVALID_DEVICE_STATE";
    case 0xC0000185: return "STATUS_IO_DEVICE_ERROR";
    case 0xC0000186: return "STATUS_DEVICE_PROTOCOL_ERROR";
    case 0xC0000187: return "STATUS_BACKUP_CONTROLLER";
    case 0xC0000188: return "STATUS_LOG_FILE_FULL";
    case 0xC0000189: return "STATUS_TOO_LATE";
    case 0xC000018A: return "STATUS_NO_TRUST_LSA_SECRET";
    case 0xC000018B: return "STATUS_NO_TRUST_SAM_ACCOUNT";
    case 0xC000018C: return "STATUS_TRUSTED_DOMAIN_FAILURE";
    case 0xC000018D: return "STATUS_TRUSTED_RELATIONSHIP_FAILURE";
    case 0xC000018E: return "STATUS_EVENTLOG_FILE_CORRUPT";
    case 0xC000018F: return "STATUS_EVENTLOG_CANT_START";
    case 0xC0000190: return "STATUS_TRUST_FAILURE";
    case 0xC0000191: return "STATUS_MUTANT_LIMIT_EXCEEDED";
    case 0xC0000192: return "STATUS_NETLOGON_NOT_STARTED";
    case 0xC0000193: return "STATUS_ACCOUNT_EXPIRED";
    case 0xC0000194: return "STATUS_POSSIBLE_DEADLOCK";
    case 0xC0000195: return "STATUS_NETWORK_CREDENTIAL_CONFLICT";
    case 0xC0000196: return "STATUS_REMOTE_SESSION_LIMIT";
    case 0xC0000197: return "STATUS_EVENTLOG_FILE_CHANGED";
    case 0xC0000198: return "STATUS_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT";
    case 0xC0000199: return "STATUS_NOLOGON_WORKSTATION_TRUST_ACCOUNT";
    case 0xC000019A: return "STATUS_NOLOGON_SERVER_TRUST_ACCOUNT";
    case 0xC000019B: return "STATUS_DOMAIN_TRUST_INCONSISTENT";
    case 0xC000019C: return "STATUS_FS_DRIVER_REQUIRED";
    case 0xC0000202: return "STATUS_NO_USER_SESSION_KEY";
    case 0xC0000203: return "STATUS_USER_SESSION_DELETED";
    case 0xC0000204: return "STATUS_RESOURCE_LANG_NOT_FOUND";
    case 0xC0000205: return "STATUS_INSUFF_SERVER_RESOURCES";
    case 0xC0000206: return "STATUS_INVALID_BUFFER_SIZE";
    case 0xC0000207: return "STATUS_INVALID_ADDRESS_COMPONENT";
    case 0xC0000208: return "STATUS_INVALID_ADDRESS_WILDCARD";
    case 0xC0000209: return "STATUS_TOO_MANY_ADDRESSES";
    case 0xC000020A: return "STATUS_ADDRESS_ALREADY_EXISTS";
    case 0xC000020B: return "STATUS_ADDRESS_CLOSED";
    case 0xC000020C: return "STATUS_CONNECTION_DISCONNECTED";
    case 0xC000020D: return "STATUS_CONNECTION_RESET";
    case 0xC000020E: return "STATUS_TOO_MANY_NODES";
    case 0xC000020F: return "STATUS_TRANSACTION_ABORTED";
    case 0xC0000210: return "STATUS_TRANSACTION_TIMED_OUT";
    case 0xC0000211: return "STATUS_TRANSACTION_NO_RELEASE";
    case 0xC0000212: return "STATUS_TRANSACTION_NO_MATCH";
    case 0xC0000213: return "STATUS_TRANSACTION_RESPONDED";
    case 0xC0000214: return "STATUS_TRANSACTION_INVALID_ID";
    case 0xC0000215: return "STATUS_TRANSACTION_INVALID_TYPE";
    case 0xC0000216: return "STATUS_NOT_SERVER_SESSION";
    case 0xC0000217: return "STATUS_NOT_CLIENT_SESSION";
    case 0xC0000218: return "STATUS_CANNOT_LOAD_REGISTRY_FILE";
    case 0xC0000219: return "STATUS_DEBUG_ATTACH_FAILED";
    case 0xC000021A: return "STATUS_SYSTEM_PROCESS_TERMINATED";
    case 0xC000021B: return "STATUS_DATA_NOT_ACCEPTED";
    case 0xC000021C: return "STATUS_NO_BROWSER_SERVERS_FOUND";
    case 0xC000021D: return "STATUS_VDM_HARD_ERROR";
    case 0xC000021E: return "STATUS_DRIVER_CANCEL_TIMEOUT";
    case 0xC000021F: return "STATUS_REPLY_MESSAGE_MISMATCH";
    case 0xC0000220: return "STATUS_MAPPED_ALIGNMENT";
    case 0xC0000221: return "STATUS_IMAGE_CHECKSUM_MISMATCH";
    case 0xC0000222: return "STATUS_LOST_WRITEBEHIND_DATA";
    case 0xC0000223: return "STATUS_CLIENT_SERVER_PARAMETERS_INVALID";
    case 0xC0000224: return "STATUS_PASSWORD_MUST_CHANGE";
    case 0xC0000225: return "STATUS_NOT_FOUND";
    case 0xC0000226: return "STATUS_NOT_TINY_STREAM";
    case 0xC0000227: return "STATUS_RECOVERY_FAILURE";
    case 0xC0000228: return "STATUS_STACK_OVERFLOW_READ";
    case 0xC0000229: return "STATUS_FAIL_CHECK";
    case 0xC000022A: return "STATUS_DUPLICATE_OBJECTID";
    case 0xC000022B: return "STATUS_OBJECTID_EXISTS";
    case 0xC000022C: return "STATUS_CONVERT_TO_LARGE";
    case 0xC000022D: return "STATUS_RETRY";
    case 0xC000022E: return "STATUS_FOUND_OUT_OF_SCOPE";
    case 0xC000022F: return "STATUS_ALLOCATE_BUCKET";
    case 0xC0000230: return "STATUS_PROPSET_NOT_FOUND";
    case 0xC0000231: return "STATUS_MARSHALL_OVERFLOW";
    case 0xC0000232: return "STATUS_INVALID_VARIANT";
    case 0xC0000233: return "STATUS_DOMAIN_CONTROLLER_NOT_FOUND";
    case 0xC0000234: return "STATUS_ACCOUNT_LOCKED_OUT";
    case 0xC0000235: return "STATUS_HANDLE_NOT_CLOSABLE";
    case 0xC0000236: return "STATUS_CONNECTION_REFUSED";
    case 0xC0000237: return "STATUS_GRACEFUL_DISCONNECT";
    case 0xC0000238: return "STATUS_ADDRESS_ALREADY_ASSOCIATED";
    case 0xC0000239: return "STATUS_ADDRESS_NOT_ASSOCIATED";
    case 0xC000023A: return "STATUS_CONNECTION_INVALID";
    case 0xC000023B: return "STATUS_CONNECTION_ACTIVE";
    case 0xC000023C: return "STATUS_NETWORK_UNREACHABLE";
    case 0xC000023D: return "STATUS_HOST_UNREACHABLE";
    case 0xC000023E: return "STATUS_PROTOCOL_UNREACHABLE";
    case 0xC000023F: return "STATUS_PORT_UNREACHABLE";
    case 0xC0000240: return "STATUS_REQUEST_ABORTED";
    case 0xC0000241: return "STATUS_CONNECTION_ABORTED";
    case 0xC0000242: return "STATUS_BAD_COMPRESSION_BUFFER";
    case 0xC0000243: return "STATUS_USER_MAPPED_FILE";
    case 0xC0000244: return "STATUS_AUDIT_FAILED";
    case 0xC0000245: return "STATUS_TIMER_RESOLUTION_NOT_SET";
    case 0xC0000246: return "STATUS_CONNECTION_COUNT_LIMIT";
    case 0xC0000247: return "STATUS_LOGIN_TIME_RESTRICTION";
    case 0xC0000248: return "STATUS_LOGIN_WKSTA_RESTRICTION";
    case 0xC0000249: return "STATUS_IMAGE_MP_UP_MISMATCH";
    case 0xC0000250: return "STATUS_INSUFFICIENT_LOGON_INFO";
    case 0xC0000251: return "STATUS_BAD_DLL_ENTRYPOINT";
    case 0xC0000252: return "STATUS_BAD_SERVICE_ENTRYPOINT";
    case 0xC0000253: return "STATUS_LPC_REPLY_LOST";
    case 0xC0000254: return "STATUS_IP_ADDRESS_CONFLICT1";
    case 0xC0000255: return "STATUS_IP_ADDRESS_CONFLICT2";
    case 0xC0000256: return "STATUS_REGISTRY_QUOTA_LIMIT";
    case 0xC0000257: return "STATUS_PATH_NOT_COVERED";
    case 0xC0000258: return "STATUS_NO_CALLBACK_ACTIVE";
    case 0xC0000259: return "STATUS_LICENSE_QUOTA_EXCEEDED";
    case 0xC000025A: return "STATUS_PWD_TOO_SHORT";
    case 0xC000025B: return "STATUS_PWD_TOO_RECENT";
    case 0xC000025C: return "STATUS_PWD_HISTORY_CONFLICT";
    case 0xC000025E: return "STATUS_PLUGPLAY_NO_DEVICE";
    case 0xC000025F: return "STATUS_UNSUPPORTED_COMPRESSION";
    case 0xC0000260: return "STATUS_INVALID_HW_PROFILE";
    case 0xC0000261: return "STATUS_INVALID_PLUGPLAY_DEVICE_PATH";
    case 0xC0000262: return "STATUS_DRIVER_ORDINAL_NOT_FOUND";
    case 0xC0000263: return "STATUS_DRIVER_ENTRYPOINT_NOT_FOUND";
    case 0xC0000264: return "STATUS_RESOURCE_NOT_OWNED";
    case 0xC0000265: return "STATUS_TOO_MANY_LINKS";
    case 0xC0000266: return "STATUS_QUOTA_LIST_INCONSISTENT";
    case 0xC0000267: return "STATUS_FILE_IS_OFFLINE";
    case 0xC0000268: return "STATUS_EVALUATION_EXPIRATION";
    case 0xC0000269: return "STATUS_ILLEGAL_DLL_RELOCATION";
    case 0xC000026A: return "STATUS_LICENSE_VIOLATION";
    case 0xC000026B: return "STATUS_DLL_INIT_FAILED_LOGOFF";
    case 0xC000026C: return "STATUS_DRIVER_UNABLE_TO_LOAD";
    case 0xC000026D: return "STATUS_DFS_UNAVAILABLE";
    case 0xC000026E: return "STATUS_VOLUME_DISMOUNTED";
    case 0xC000026F: return "STATUS_WX86_INTERNAL_ERROR";
    case 0xC0000270: return "STATUS_WX86_FLOAT_STACK_CHECK";
    case 0xC0000271: return "STATUS_VALIDATE_CONTINUE";
    case 0xC0000272: return "STATUS_NO_MATCH";
    case 0xC0000273: return "STATUS_NO_MORE_MATCHES";
    case 0xC0000275: return "STATUS_NOT_A_REPARSE_POINT";
    case 0xC0000276: return "STATUS_IO_REPARSE_TAG_INVALID";
    case 0xC0000277: return "STATUS_IO_REPARSE_TAG_MISMATCH";
    case 0xC0000278: return "STATUS_IO_REPARSE_DATA_INVALID";
    case 0xC0000279: return "STATUS_IO_REPARSE_TAG_NOT_HANDLED";
    case 0xC0000280: return "STATUS_REPARSE_POINT_NOT_RESOLVED";
    case 0xC0000281: return "STATUS_DIRECTORY_IS_A_REPARSE_POINT";
    case 0xC0000282: return "STATUS_RANGE_LIST_CONFLICT";
    case 0xC0000283: return "STATUS_SOURCE_ELEMENT_EMPTY";
    case 0xC0000284: return "STATUS_DESTINATION_ELEMENT_FULL";
    case 0xC0000285: return "STATUS_ILLEGAL_ELEMENT_ADDRESS";
    case 0xC0000286: return "STATUS_MAGAZINE_NOT_PRESENT";
    case 0xC0000287: return "STATUS_REINITIALIZATION_NEEDED";
    case 0x80000288: return "STATUS_DEVICE_REQUIRES_CLEANING";
    case 0x80000289: return "STATUS_DEVICE_DOOR_OPEN";
    case 0xC000028A: return "STATUS_ENCRYPTION_FAILED";
    case 0xC000028B: return "STATUS_DECRYPTION_FAILED";
    case 0xC000028C: return "STATUS_RANGE_NOT_FOUND";
    case 0xC000028D: return "STATUS_NO_RECOVERY_POLICY";
    case 0xC000028E: return "STATUS_NO_EFS";
    case 0xC000028F: return "STATUS_WRONG_EFS";
    case 0xC0000290: return "STATUS_NO_USER_KEYS";
    case 0xC0000291: return "STATUS_FILE_NOT_ENCRYPTED";
    case 0xC0000292: return "STATUS_NOT_EXPORT_FORMAT";
    case 0xC0000293: return "STATUS_FILE_ENCRYPTED";
    case 0x40000294: return "STATUS_WAKE_SYSTEM";
    case 0xC0000295: return "STATUS_WMI_GUID_NOT_FOUND";
    case 0xC0000296: return "STATUS_WMI_INSTANCE_NOT_FOUND";
    case 0xC0000297: return "STATUS_WMI_ITEMID_NOT_FOUND";
    case 0xC0000298: return "STATUS_WMI_TRY_AGAIN";
    case 0xC0000299: return "STATUS_SHARED_POLICY";
    case 0xC000029A: return "STATUS_POLICY_OBJECT_NOT_FOUND";
    case 0xC000029B: return "STATUS_POLICY_ONLY_IN_DS";
    case 0xC000029C: return "STATUS_VOLUME_NOT_UPGRADED";
    case 0xC000029D: return "STATUS_REMOTE_STORAGE_NOT_ACTIVE";
    case 0xC000029E: return "STATUS_REMOTE_STORAGE_MEDIA_ERROR";
    case 0xC000029F: return "STATUS_NO_TRACKING_SERVICE";
    case 0xC00002A0: return "STATUS_SERVER_SID_MISMATCH";
    case 0xC00002A1: return "STATUS_DS_NO_ATTRIBUTE_OR_VALUE";
    case 0xC00002A2: return "STATUS_DS_INVALID_ATTRIBUTE_SYNTAX";
    case 0xC00002A3: return "STATUS_DS_ATTRIBUTE_TYPE_UNDEFINED";
    case 0xC00002A4: return "STATUS_DS_ATTRIBUTE_OR_VALUE_EXISTS";
    case 0xC00002A5: return "STATUS_DS_BUSY";
    case 0xC00002A6: return "STATUS_DS_UNAVAILABLE";
    case 0xC00002A7: return "STATUS_DS_NO_RIDS_ALLOCATED";
    case 0xC00002A8: return "STATUS_DS_NO_MORE_RIDS";
    case 0xC00002A9: return "STATUS_DS_INCORRECT_ROLE_OWNER";
    case 0xC00002AA: return "STATUS_DS_RIDMGR_INIT_ERROR";
    case 0xC00002AB: return "STATUS_DS_OBJ_CLASS_VIOLATION";
    case 0xC00002AC: return "STATUS_DS_CANT_ON_NON_LEAF";
    case 0xC00002AD: return "STATUS_DS_CANT_ON_RDN";
    case 0xC00002AE: return "STATUS_DS_CANT_MOD_OBJ_CLASS";
    case 0xC00002AF: return "STATUS_DS_CROSS_DOM_MOVE_FAILED";
    case 0xC00002B0: return "STATUS_DS_GC_NOT_AVAILABLE";
    case 0xC00002B1: return "STATUS_DIRECTORY_SERVICE_REQUIRED";
    case 0xC00002B2: return "STATUS_REPARSE_ATTRIBUTE_CONFLICT";
    case 0xC00002B3: return "STATUS_CANT_ENABLE_DENY_ONLY";
    case 0xC00002B4: return "STATUS_FLOAT_MULTIPLE_FAULTS";
    case 0xC00002B5: return "STATUS_FLOAT_MULTIPLE_TRAPS";
    case 0xC00002B6: return "STATUS_DEVICE_REMOVED";
    case 0xC00002B7: return "STATUS_JOURNAL_DELETE_IN_PROGRESS";
    case 0xC00002B8: return "STATUS_JOURNAL_NOT_ACTIVE";
    case 0xC00002B9: return "STATUS_NOINTERFACE";
    case 0xC00002C1: return "STATUS_DS_ADMIN_LIMIT_EXCEEDED";
    case 0xC00002C2: return "STATUS_DRIVER_FAILED_SLEEP";
    case 0xC00002C3: return "STATUS_MUTUAL_AUTHENTICATION_FAILED";
    case 0xC00002C4: return "STATUS_CORRUPT_SYSTEM_FILE";
    case 0xC00002C5: return "STATUS_DATATYPE_MISALIGNMENT_ERROR";
    case 0xC00002C6: return "STATUS_WMI_READ_ONLY";
    case 0xC00002C7: return "STATUS_WMI_SET_FAILURE";
    case 0xC00002C8: return "STATUS_COMMITMENT_MINIMUM";
    case 0xC00002C9: return "STATUS_REG_NAT_CONSUMPTION";
    case 0xC00002CA: return "STATUS_TRANSPORT_FULL";
    case 0xC00002CB: return "STATUS_DS_SAM_INIT_FAILURE";
    case 0xC00002CC: return "STATUS_ONLY_IF_CONNECTED";
    case 0xC00002CD: return "STATUS_DS_SENSITIVE_GROUP_VIOLATION";
    case 0xC00002CE: return "STATUS_PNP_RESTART_ENUMERATION";
    case 0xC00002CF: return "STATUS_JOURNAL_ENTRY_DELETED";
    case 0xC00002D0: return "STATUS_DS_CANT_MOD_PRIMARYGROUPID";
    case 0xC00002D1: return "STATUS_SYSTEM_IMAGE_BAD_SIGNATURE";
    case 0xC00002D2: return "STATUS_PNP_REBOOT_REQUIRED";
    case 0xC00002D3: return "STATUS_POWER_STATE_INVALID";
    case 0xC00002D4: return "STATUS_DS_INVALID_GROUP_TYPE";
    case 0xC00002D5: return "STATUS_DS_NO_NEST_GLOBALGROUP_IN_MIXEDDOMAIN";
    case 0xC00002D6: return "STATUS_DS_NO_NEST_LOCALGROUP_IN_MIXEDDOMAIN";
    case 0xC00002D7: return "STATUS_DS_GLOBAL_CANT_HAVE_LOCAL_MEMBER";
    case 0xC00002D8: return "STATUS_DS_GLOBAL_CANT_HAVE_UNIVERSAL_MEMBER";
    case 0xC00002D9: return "STATUS_DS_UNIVERSAL_CANT_HAVE_LOCAL_MEMBER";
    case 0xC00002DA: return "STATUS_DS_GLOBAL_CANT_HAVE_CROSSDOMAIN_MEMBER";
    case 0xC00002DB: return "STATUS_DS_LOCAL_CANT_HAVE_CROSSDOMAIN_LOCAL_MEMBER";
    case 0xC00002DC: return "STATUS_DS_HAVE_PRIMARY_MEMBERS";
    case 0xC00002DD: return "STATUS_WMI_NOT_SUPPORTED";
    case 0xC00002DE: return "STATUS_INSUFFICIENT_POWER";
    case 0xC00002DF: return "STATUS_SAM_NEED_BOOTKEY_PASSWORD";
    case 0xC00002E0: return "STATUS_SAM_NEED_BOOTKEY_FLOPPY";
    case 0xC00002E1: return "STATUS_DS_CANT_START";
    case 0xC00002E2: return "STATUS_DS_INIT_FAILURE";
    case 0xC00002E3: return "STATUS_SAM_INIT_FAILURE";
    case 0xC00002E4: return "STATUS_DS_GC_REQUIRED";
    case 0xC00002E5: return "STATUS_DS_LOCAL_MEMBER_OF_LOCAL_ONLY";
    case 0xC00002E6: return "STATUS_DS_NO_FPO_IN_UNIVERSAL_GROUPS";
    case 0xC00002E7: return "STATUS_DS_MACHINE_ACCOUNT_QUOTA_EXCEEDED";
    case 0xC00002E8: return "STATUS_MULTIPLE_FAULT_VIOLATION";
    case 0xC0000300: return "STATUS_NOT_SUPPORTED_ON_SBS";
    case 0xC0009898: return "STATUS_WOW_ASSERTION";
    case 0xC0010001: return "DBG_NO_STATE_CHANGE";
    case 0xC0010002: return "DBG_APP_NOT_IDLE";
    case 0xC0020001: return "RPC_NT_INVALID_STRING_BINDING";
    case 0xC0020002: return "RPC_NT_WRONG_KIND_OF_BINDING";
    case 0xC0020003: return "RPC_NT_INVALID_BINDING";
    case 0xC0020004: return "RPC_NT_PROTSEQ_NOT_SUPPORTED";
    case 0xC0020005: return "RPC_NT_INVALID_RPC_PROTSEQ";
    case 0xC0020006: return "RPC_NT_INVALID_STRING_UUID";
    case 0xC0020007: return "RPC_NT_INVALID_ENDPOINT_FORMAT";
    case 0xC0020008: return "RPC_NT_INVALID_NET_ADDR";
    case 0xC0020009: return "RPC_NT_NO_ENDPOINT_FOUND";
    case 0xC002000A: return "RPC_NT_INVALID_TIMEOUT";
    case 0xC002000B: return "RPC_NT_OBJECT_NOT_FOUND";
    case 0xC002000C: return "RPC_NT_ALREADY_REGISTERED";
    case 0xC002000D: return "RPC_NT_TYPE_ALREADY_REGISTERED";
    case 0xC002000E: return "RPC_NT_ALREADY_LISTENING";
    case 0xC002000F: return "RPC_NT_NO_PROTSEQS_REGISTERED";
    case 0xC0020010: return "RPC_NT_NOT_LISTENING";
    case 0xC0020011: return "RPC_NT_UNKNOWN_MGR_TYPE";
    case 0xC0020012: return "RPC_NT_UNKNOWN_IF";
    case 0xC0020013: return "RPC_NT_NO_BINDINGS";
    case 0xC0020014: return "RPC_NT_NO_PROTSEQS";
    case 0xC0020015: return "RPC_NT_CANT_CREATE_ENDPOINT";
    case 0xC0020016: return "RPC_NT_OUT_OF_RESOURCES";
    case 0xC0020017: return "RPC_NT_SERVER_UNAVAILABLE";
    case 0xC0020018: return "RPC_NT_SERVER_TOO_BUSY";
    case 0xC0020019: return "RPC_NT_INVALID_NETWORK_OPTIONS";
    case 0xC002001A: return "RPC_NT_NO_CALL_ACTIVE";
    case 0xC002001B: return "RPC_NT_CALL_FAILED";
    case 0xC002001C: return "RPC_NT_CALL_FAILED_DNE";
    case 0xC002001D: return "RPC_NT_PROTOCOL_ERROR";
    case 0xC002001F: return "RPC_NT_UNSUPPORTED_TRANS_SYN";
    case 0xC0020021: return "RPC_NT_UNSUPPORTED_TYPE";
    case 0xC0020022: return "RPC_NT_INVALID_TAG";
    case 0xC0020023: return "RPC_NT_INVALID_BOUND";
    case 0xC0020024: return "RPC_NT_NO_ENTRY_NAME";
    case 0xC0020025: return "RPC_NT_INVALID_NAME_SYNTAX";
    case 0xC0020026: return "RPC_NT_UNSUPPORTED_NAME_SYNTAX";
    case 0xC0020028: return "RPC_NT_UUID_NO_ADDRESS";
    case 0xC0020029: return "RPC_NT_DUPLICATE_ENDPOINT";
    case 0xC002002A: return "RPC_NT_UNKNOWN_AUTHN_TYPE";
    case 0xC002002B: return "RPC_NT_MAX_CALLS_TOO_SMALL";
    case 0xC002002C: return "RPC_NT_STRING_TOO_LONG";
    case 0xC002002D: return "RPC_NT_PROTSEQ_NOT_FOUND";
    case 0xC002002E: return "RPC_NT_PROCNUM_OUT_OF_RANGE";
    case 0xC002002F: return "RPC_NT_BINDING_HAS_NO_AUTH";
    case 0xC0020030: return "RPC_NT_UNKNOWN_AUTHN_SERVICE";
    case 0xC0020031: return "RPC_NT_UNKNOWN_AUTHN_LEVEL";
    case 0xC0020032: return "RPC_NT_INVALID_AUTH_IDENTITY";
    case 0xC0020033: return "RPC_NT_UNKNOWN_AUTHZ_SERVICE";
    case 0xC0020034: return "EPT_NT_INVALID_ENTRY";
    case 0xC0020035: return "EPT_NT_CANT_PERFORM_OP";
    case 0xC0020036: return "EPT_NT_NOT_REGISTERED";
    case 0xC0020037: return "RPC_NT_NOTHING_TO_EXPORT";
    case 0xC0020038: return "RPC_NT_INCOMPLETE_NAME";
    case 0xC0020039: return "RPC_NT_INVALID_VERS_OPTION";
    case 0xC002003A: return "RPC_NT_NO_MORE_MEMBERS";
    case 0xC002003B: return "RPC_NT_NOT_ALL_OBJS_UNEXPORTED";
    case 0xC002003C: return "RPC_NT_INTERFACE_NOT_FOUND";
    case 0xC002003D: return "RPC_NT_ENTRY_ALREADY_EXISTS";
    case 0xC002003E: return "RPC_NT_ENTRY_NOT_FOUND";
    case 0xC002003F: return "RPC_NT_NAME_SERVICE_UNAVAILABLE";
    case 0xC0020040: return "RPC_NT_INVALID_NAF_ID";
    case 0xC0020041: return "RPC_NT_CANNOT_SUPPORT";
    case 0xC0020042: return "RPC_NT_NO_CONTEXT_AVAILABLE";
    case 0xC0020043: return "RPC_NT_INTERNAL_ERROR";
    case 0xC0020044: return "RPC_NT_ZERO_DIVIDE";
    case 0xC0020045: return "RPC_NT_ADDRESS_ERROR";
    case 0xC0020046: return "RPC_NT_FP_DIV_ZERO";
    case 0xC0020047: return "RPC_NT_FP_UNDERFLOW";
    case 0xC0020048: return "RPC_NT_FP_OVERFLOW";
    case 0xC0030001: return "RPC_NT_NO_MORE_ENTRIES";
    case 0xC0030002: return "RPC_NT_SS_CHAR_TRANS_OPEN_FAIL";
    case 0xC0030003: return "RPC_NT_SS_CHAR_TRANS_SHORT_FILE";
    case 0xC0030004: return "RPC_NT_SS_IN_NULL_CONTEXT";
    case 0xC0030005: return "RPC_NT_SS_CONTEXT_MISMATCH";
    case 0xC0030006: return "RPC_NT_SS_CONTEXT_DAMAGED";
    case 0xC0030007: return "RPC_NT_SS_HANDLES_MISMATCH";
    case 0xC0030008: return "RPC_NT_SS_CANNOT_GET_CALL_HANDLE";
    case 0xC0030009: return "RPC_NT_NULL_REF_POINTER";
    case 0xC003000A: return "RPC_NT_ENUM_VALUE_OUT_OF_RANGE";
    case 0xC003000B: return "RPC_NT_BYTE_COUNT_TOO_SMALL";
    case 0xC003000C: return "RPC_NT_BAD_STUB_DATA";
    case 0xC0020049: return "RPC_NT_CALL_IN_PROGRESS";
    case 0xC002004A: return "RPC_NT_NO_MORE_BINDINGS";
    case 0xC002004B: return "RPC_NT_GROUP_MEMBER_NOT_FOUND";
    case 0xC002004C: return "EPT_NT_CANT_CREATE";
    case 0xC002004D: return "RPC_NT_INVALID_OBJECT";
    case 0xC002004F: return "RPC_NT_NO_INTERFACES";
    case 0xC0020050: return "RPC_NT_CALL_CANCELLED";
    case 0xC0020051: return "RPC_NT_BINDING_INCOMPLETE";
    case 0xC0020052: return "RPC_NT_COMM_FAILURE";
    case 0xC0020053: return "RPC_NT_UNSUPPORTED_AUTHN_LEVEL";
    case 0xC0020054: return "RPC_NT_NO_PRINC_NAME";
    case 0xC0020055: return "RPC_NT_NOT_RPC_ERROR";
    case 0x40020056: return "RPC_NT_UUID_LOCAL_ONLY";
    case 0xC0020057: return "RPC_NT_SEC_PKG_ERROR";
    case 0xC0020058: return "RPC_NT_NOT_CANCELLED";
    case 0xC0030059: return "RPC_NT_INVALID_ES_ACTION";
    case 0xC003005A: return "RPC_NT_WRONG_ES_VERSION";
    case 0xC003005B: return "RPC_NT_WRONG_STUB_VERSION";
    case 0xC003005C: return "RPC_NT_INVALID_PIPE_OBJECT";
    case 0xC003005D: return "RPC_NT_INVALID_PIPE_OPERATION";
    case 0xC003005E: return "RPC_NT_WRONG_PIPE_VERSION";
    case 0xC003005F: return "RPC_NT_PIPE_CLOSED";
    case 0xC0030060: return "RPC_NT_PIPE_DISCIPLINE_ERROR";
    case 0xC0030061: return "RPC_NT_PIPE_EMPTY";
    case 0xC0020062: return "RPC_NT_INVALID_ASYNC_HANDLE";
    case 0xC0020063: return "RPC_NT_INVALID_ASYNC_CALL";
    case 0x400200AF: return "RPC_NT_SEND_INCOMPLETE";
    case 0xC0140001: return "STATUS_ACPI_INVALID_OPCODE";
    case 0xC0140002: return "STATUS_ACPI_STACK_OVERFLOW";
    case 0xC0140003: return "STATUS_ACPI_ASSERT_FAILED";
    case 0xC0140004: return "STATUS_ACPI_INVALID_INDEX";
    case 0xC0140005: return "STATUS_ACPI_INVALID_ARGUMENT";
    case 0xC0140006: return "STATUS_ACPI_FATAL";
    case 0xC0140007: return "STATUS_ACPI_INVALID_SUPERNAME";
    case 0xC0140008: return "STATUS_ACPI_INVALID_ARGTYPE";
    case 0xC0140009: return "STATUS_ACPI_INVALID_OBJTYPE";
    case 0xC014000A: return "STATUS_ACPI_INVALID_TARGETTYPE";
    case 0xC014000B: return "STATUS_ACPI_INCORRECT_ARGUMENT_COUNT";
    case 0xC014000C: return "STATUS_ACPI_ADDRESS_NOT_MAPPED";
    case 0xC014000D: return "STATUS_ACPI_INVALID_EVENTTYPE";
    case 0xC014000E: return "STATUS_ACPI_HANDLER_COLLISION";
    case 0xC014000F: return "STATUS_ACPI_INVALID_DATA";
    case 0xC0140010: return "STATUS_ACPI_INVALID_REGION";
    case 0xC0140011: return "STATUS_ACPI_INVALID_ACCESS_SIZE";
    case 0xC0140012: return "STATUS_ACPI_ACQUIRE_GLOBAL_LOCK";
    case 0xC0140013: return "STATUS_ACPI_ALREADY_INITIALIZED";
    case 0xC0140014: return "STATUS_ACPI_NOT_INITIALIZED";
    case 0xC0140015: return "STATUS_ACPI_INVALID_MUTEX_LEVEL";
    case 0xC0140016: return "STATUS_ACPI_MUTEX_NOT_OWNED";
    case 0xC0140017: return "STATUS_ACPI_MUTEX_NOT_OWNER";
    case 0xC0140018: return "STATUS_ACPI_RS_ACCESS";
    case 0xC0140019: return "STATUS_ACPI_INVALID_TABLE";
    case 0xC0140020: return "STATUS_ACPI_REG_HANDLER_FAILED";
    case 0xC0140021: return "STATUS_ACPI_POWER_REQUEST_FAILED";
    case 0xC00A0001: return "STATUS_CTX_WINSTATION_NAME_INVALID";
    case 0xC00A0002: return "STATUS_CTX_INVALID_PD";
    case 0xC00A0003: return "STATUS_CTX_PD_NOT_FOUND";
    case 0x400A0004: return "STATUS_CTX_CDM_CONNECT";
    case 0x400A0005: return "STATUS_CTX_CDM_DISCONNECT";
    case 0xC00A0006: return "STATUS_CTX_CLOSE_PENDING";
    case 0xC00A0007: return "STATUS_CTX_NO_OUTBUF";
    case 0xC00A0008: return "STATUS_CTX_MODEM_INF_NOT_FOUND";
    case 0xC00A0009: return "STATUS_CTX_INVALID_MODEMNAME";
    case 0xC00A000A: return "STATUS_CTX_RESPONSE_ERROR";
    case 0xC00A000B: return "STATUS_CTX_MODEM_RESPONSE_TIMEOUT";
    case 0xC00A000C: return "STATUS_CTX_MODEM_RESPONSE_NO_CARRIER";
    case 0xC00A000D: return "STATUS_CTX_MODEM_RESPONSE_NO_DIALTONE";
    case 0xC00A000E: return "STATUS_CTX_MODEM_RESPONSE_BUSY";
    case 0xC00A000F: return "STATUS_CTX_MODEM_RESPONSE_VOICE";
    case 0xC00A0010: return "STATUS_CTX_TD_ERROR";
    case 0xC00A0012: return "STATUS_CTX_LICENSE_CLIENT_INVALID";
    case 0xC00A0013: return "STATUS_CTX_LICENSE_NOT_AVAILABLE";
    case 0xC00A0014: return "STATUS_CTX_LICENSE_EXPIRED";
    case 0xC00A0015: return "STATUS_CTX_WINSTATION_NOT_FOUND";
    case 0xC00A0016: return "STATUS_CTX_WINSTATION_NAME_COLLISION";
    case 0xC00A0017: return "STATUS_CTX_WINSTATION_BUSY";
    case 0xC00A0018: return "STATUS_CTX_BAD_VIDEO_MODE";
    case 0xC00A0022: return "STATUS_CTX_GRAPHICS_INVALID";
    case 0xC00A0024: return "STATUS_CTX_NOT_CONSOLE";
    case 0xC00A0026: return "STATUS_CTX_CLIENT_QUERY_TIMEOUT";
    case 0xC00A0027: return "STATUS_CTX_CONSOLE_DISCONNECT";
    case 0xC00A0028: return "STATUS_CTX_CONSOLE_CONNECT";
    case 0xC00A002A: return "STATUS_CTX_SHADOW_DENIED";
    case 0xC00A002B: return "STATUS_CTX_WINSTATION_ACCESS_DENIED";
    case 0xC00A002E: return "STATUS_CTX_INVALID_WD";
    case 0xC00A002F: return "STATUS_CTX_WD_NOT_FOUND";
    case 0xC00A0030: return "STATUS_CTX_SHADOW_INVALID";
    case 0xC00A0031: return "STATUS_CTX_SHADOW_DISABLED";
    case 0xC00A0032: return "STATUS_RDP_PROTOCOL_ERROR";
    case 0xC00A0033: return "STATUS_CTX_CLIENT_LICENSE_NOT_SET";
    case 0xC00A0034: return "STATUS_CTX_CLIENT_LICENSE_IN_USE";
    case 0xC0040035: return "STATUS_PNP_BAD_MPS_TABLE";
    case 0xC0040036: return "STATUS_PNP_TRANSLATION_FAILED";
    case 0xC0040037: return "STATUS_PNP_IRQ_TRANSLATION_FAILED";
    default:         return "STATUS_UNKNOWN";
    }
}

// PsCreateSystemThread proxy procedure
#pragma warning(push)
#pragma warning(disable: 4731)  // disable ebp modification warning
static unsigned int WINAPI PCSTProxy
(
    IN PVOID Parameter
)
{
    PCSTProxyParam *iPCSTProxyParam = (PCSTProxyParam*)Parameter;

    uint32 StartContext1 = (uint32)iPCSTProxyParam->StartContext1;
    uint32 StartContext2 = (uint32)iPCSTProxyParam->StartContext2;
    uint32 StartRoutine  = (uint32)iPCSTProxyParam->StartRoutine;
    BOOL   StartSuspended = (BOOL)iPCSTProxyParam->StartSuspended;
    HANDLE hStartedEvent = (HANDLE)iPCSTProxyParam->hStartedEvent;

    // Once deleted, unable to directly access iPCSTProxyParam in remainder of function.
    delete iPCSTProxyParam;

    DbgPrintf("EmuKrnl (0x%X): PCSTProxy\n"
           "(\n"
           "   StartContext1       : 0x%.08X\n"
           "   StartContext2       : 0x%.08X\n"
           "   StartRoutine        : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), StartContext1, StartContext2, StartRoutine);

    if(StartSuspended == TRUE)
        SuspendThread(GetCurrentThread());

    EmuGenerateFS(CxbxKrnl_TLS, CxbxKrnl_TLSData);

    // call thread notification routine(s)
    if(g_iThreadNotificationCount != 0)
    {
		for(int i = 0; i < 16; i++ )
		{
			XTL::XTHREAD_NOTIFY_PROC pfnNotificationRoutine = (XTL::XTHREAD_NOTIFY_PROC)g_pfnThreadNotification[i];

			// If the routine doesn't exist, don't execute it!
			if(pfnNotificationRoutine == NULL)
				continue;

			DbgPrintf("EmuKrnl (0x%X): Calling pfnNotificationRoutine[%d] (0x%.08X)\n", g_iThreadNotificationCount, GetCurrentThreadId(), pfnNotificationRoutine);

			EmuSwapFS();   // Xbox FS

			pfnNotificationRoutine(TRUE);

			EmuSwapFS();   // Win2k/XP FS
		}
    }

    // use the special calling convention
    __try
    {
        SetEvent(hStartedEvent);

        EmuSwapFS();   // Xbox FS

        __asm
        {
            mov         esi, StartRoutine
            push        StartContext2
            push        StartContext1
            push        offset callComplete
            lea         ebp, [esp-4]
            jmp near    esi
        }
    }
    __except(EmuException(GetExceptionInformation()))
    {
        EmuWarning("Problem with ExceptionFilter!");
    }

callComplete:

    EmuSwapFS();    // Win2k/XP FS

    // call thread notification routine(s)
    if(g_iThreadNotificationCount != 0)
    {
		for(int i = 0; i < 16; i++ )
		{
			XTL::XTHREAD_NOTIFY_PROC pfnNotificationRoutine = (XTL::XTHREAD_NOTIFY_PROC)g_pfnThreadNotification[i];

			// If the routine doesn't exist, don't execute it!
			if(pfnNotificationRoutine == NULL)
				continue;

			DbgPrintf("EmuKrnl (0x%X): Calling pfnNotificationRoutine[%d] (0x%.08X)\n", g_iThreadNotificationCount, GetCurrentThreadId(), pfnNotificationRoutine);

			EmuSwapFS();   // Xbox FS

			pfnNotificationRoutine(FALSE);

			EmuSwapFS();   // Win2k/XP FS
		}
    }

    CxbxKrnlTerminateThread();

    return 0;
}
#pragma warning(pop)

using namespace xboxkrnl;

// ******************************************************************
// * 0x0001 AvGetSavedDataAddress()
// ******************************************************************
XBSYSAPI EXPORTNUM(1) xboxkrnl::PVOID NTAPI xboxkrnl::AvGetSavedDataAddress()
{
	EmuSwapFS();	// Win2k/XP FS

	DbgPrintf("EmuKrnl (0x%X): AvGetSavedDataAddress();\n", GetCurrentThreadId() );

	__asm int 3;

	// Allocate a buffer the size of the screen buffer and return that.
	// TODO: Fill this buffer with the contents of the front buffer.
	// TODO: This isn't always the size we need...

	if( g_pPersistedData )
	{
		CxbxFree( g_pPersistedData );
		g_pPersistedData = NULL;
	}

	g_pPersistedData = CxbxMalloc( 640*480*4 );

#if 0
	// Get a copy of the front buffer
	IDirect3DSurface8* pFrontBuffer = NULL;

	if( SUCCEEDED(g_pD3DDevice8->GetFrontBuffer(pFrontBuffer)))
	{
		D3DLOCKED_RECT LockedRect;
		pFrontBuffer->LockRect( 0, NULL, &LockedRect );

		CopyMemory( g_pPersistedData, LockRect.pBits, 640*480*4 );

		pFrontBuffer->UnlockRect();
	}
#endif

	// TODO: We might want to return something sometime...
	/*if( !g_pPersistedData )
	{
		FILE* fp = fopen( "PersistedSurface.bin", "rb" );
		fseek( fp, 0, SEEK_END );
		long size = ftell( fp );
		g_pPersistedData = malloc( size );
		fread( g_pPersistedData, size, 1, fp );
		fclose(fp);
	}*/

	EmuSwapFS();	// Xbox FS

	return NULL;//g_pPersistedData;
}

// ******************************************************************
// * 0x0002 AvSendTVEncoderOption()
// ******************************************************************
XBSYSAPI EXPORTNUM(2) VOID NTAPI xboxkrnl::AvSendTVEncoderOption
(
    IN  PVOID   RegisterBase,
    IN  ULONG   Option,
    IN  ULONG   Param,
    OUT ULONG   *Result
)
{
	EmuSwapFS();	// Win2k/XP FS

	DbgPrintf("EmuKrnl (0x%X): AvSendTVEncoderOption\n"
           "(\n"
           "   RegisterBase       : 0x%.08X\n"
		   "   Option             : 0x%.08X\n"
		   "   Param              : 0x%.08X\n"
		   "   Result             : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), RegisterBase, Option, Param, Result);

	// TODO: What does this do?
	EmuWarning( "AvSendTVEncoderOption ignored!" );

	EmuSwapFS();   // Xbox FS
}

// ******************************************************************
// * 0x0008 DbgPrint
// ******************************************************************
XBSYSAPI EXPORTNUM(8) xboxkrnl::ULONG _cdecl xboxkrnl::DbgPrint
(
	PCHAR  Format, ...
)
{
	EmuSwapFS();   // Win2k/XP FS

	DbgPrintf( "EmuKrnl (0x%X): DbgPrint\n"
		"(\n"
		"   Format              : 0x%.08X\n"
		"   ...\n"
		");\n",
		GetCurrentThreadId(), Format);

	if(Format != NULL) 
	{
		char szBuffer[MAX_PATH];

		va_list argp;
		va_start(argp, Format);

		vsprintf(szBuffer, Format, argp);
		va_end(argp);

		//LogPrintf("[EmuKrnl] DbgPrint: %s", szBuffer);

		EmuWarning(szBuffer);
		//DbgPrintf(szBuffer);
	}

	EmuSwapFS();   // Xbox FS

	return STATUS_SUCCESS;
}

// ******************************************************************
// * 0x0009 HalReadSMCTrayState
// ******************************************************************
XBSYSAPI EXPORTNUM(9) VOID NTAPI xboxkrnl::HalReadSMCTrayState
(
	DWORD*	State,
	DWORD*	Count
)
{
	EmuSwapFS();	// Win2k/XP FS
	
	DbgPrintf("EmuKrnl (0x%X): HalReadSMCTrayState\n"
           "(\n"
           "   State              : 0x%.08X\n"
		   "   Count              : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), State, Count);

#define TRAY_CLOSED_MEDIA_PRESENT 96
#define TRAY_CLOSED_NO_MEDIA 64
#define TRAY_OPEN 16

	// TODO: Make this configurable?
	// TODO: What is the count parameter for??

	*State = TRAY_CLOSED_NO_MEDIA;
//	*Count = 1;

	EmuSwapFS();	// Xbox FS
}

// ******************************************************************
// * 0x000E ExAllocatePool
// ******************************************************************
XBSYSAPI EXPORTNUM(14) xboxkrnl::PVOID NTAPI xboxkrnl::ExAllocatePool
(
    IN ULONG NumberOfBytes
)
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): ExAllocatePool\n"
           "(\n"
           "   NumberOfBytes       : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), NumberOfBytes);

    PVOID pRet = ExAllocatePoolWithTag(NumberOfBytes, (ULONG)"enoN");

    EmuSwapFS();   // Xbox FS

    return pRet;
}

// ******************************************************************
// * 0x000F ExAllocatePoolWithTag
// ******************************************************************
// * Differences from NT: There is no PoolType field, as the XBOX
// * only has 1 pool, the non-paged pool.
// ******************************************************************
XBSYSAPI EXPORTNUM(15) xboxkrnl::PVOID NTAPI xboxkrnl::ExAllocatePoolWithTag
(
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
)
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): ExAllocatePoolWithTag\n"
           "(\n"
           "   NumberOfBytes       : 0x%.08X\n"
           "   Tag                 : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), NumberOfBytes, Tag);

    // TODO: Actually implement this
    PVOID pRet = CxbxMalloc(NumberOfBytes);

    EmuSwapFS();   // Xbox FS

    return pRet;
}

// ******************************************************************
// * 0x0011 ExFreePool
// ******************************************************************
XBSYSAPI EXPORTNUM(17) VOID NTAPI xboxkrnl::ExFreePool
(
	IN PVOID	P
)
{
	EmuSwapFS();	// Win2k/XP FS
	
	DbgPrintf("EmuKrnl (0x%X): ExFreePool\n"
           "(\n"
           "   P                  : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), P);

	CxbxFree(P);

	EmuSwapFS();	// Xbox FS
}

// ******************************************************************
// * 0x0018 ExQueryNonVolatileSetting
// ******************************************************************
XBSYSAPI EXPORTNUM(24) xboxkrnl::NTSTATUS NTAPI xboxkrnl::ExQueryNonVolatileSetting
(
    IN  EEPROM_INDEX        ValueIndex,
    OUT DWORD              *Type,
    OUT PUCHAR              Value,
    IN  SIZE_T              ValueLength,
    OUT PSIZE_T             ResultLength OPTIONAL
)
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): ExQueryNonVolatileSetting\n"
           "(\n"
           "   ValueIndex          : 0x%.08X\n"
           "   Type                : 0x%.08X\n"
           "   Value               : 0x%.08X\n"
           "   ValueLength         : 0x%.08X\n"
           "   ResultLength        : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), ValueIndex, Type, Value, ValueLength, ResultLength);

    if (!Type || !Value)
        CxbxKrnlCleanup("Assertion in ExQueryNonVolatileSetting()");

    NTSTATUS ret = STATUS_SUCCESS;

    // handle eeprom read
    switch(ValueIndex)
    {
        // Factory Game Region
        case EEPROM_FACTORY_GAME_REGION:
        {
            // TODO: configurable region or autodetect of some sort
            if(ResultLength != 0)
                *ResultLength = 0x04;

            if(ValueLength >= 4) {
                *Type = 0x04;
                *Value = 0x01;  // North America
            }
        }
        break;

        // Factory AV Region
        case EEPROM_FACTORY_AV_REGION:
        {
            // TODO: configurable region or autodetect of some sort
            if(ResultLength != 0)
                *ResultLength = 0x04;
			
            *Type = 0x04;
            *Value = 0x01; // NTSC_M
        }
        break;

        // Language
        case EEPROM_LANGUAGE:
        {
            // TODO: configurable language or autodetect of some sort
            if(ResultLength != 0)
                *ResultLength = 0x04;

            *Type = 0x04;
            *Value = 0x01;  // English
        }
        break;

        // Video Flag
        case EEPROM_VIDEO:
        {
            // TODO: configurable video flags or autodetect of some sort
            if(ResultLength != 0)
                *ResultLength = 0x04;

            *Type = 0x04;
            *Value = 0x10;  // Letterbox
        }
        break;

        // Audio Flags
        case EEPROM_AUDIO:
        {
            if(ResultLength != 0)
                *ResultLength = 0x04;            
            
            *Type = 0x04;
            *Value = 0;  // Stereo, no AC3, no DTS
        }
        break;

        case EEPROM_MISC:
        {
            if(ResultLength != 0)
                *ResultLength = 0x04;
            
            *Type  = 0x04;
            *Value = 0;  // No automatic power down
        }
        break;

        case EEPROM_MAX_OS:
        {
            // This is called to return a complete XBOX_USER_SETTINGS structure
            //
            // One example is from XapipQueryTimeZoneInformation(), where it is used to
            // detect the local timezone information.

            // TODO
        }
        break;

        default:
            EmuWarning("ExQueryNonVolatileSetting unknown ValueIndex (%d)", ValueIndex);
            ret = STATUS_OBJECT_NAME_NOT_FOUND;
            break;
    }

    EmuSwapFS();   // Xbox FS

    return ret;
}

// ******************************************************************
// * 0x0019 - ExReadWriteRefurbInfo
// ******************************************************************
XBSYSAPI EXPORTNUM(25) xboxkrnl::NTSTATUS NTAPI xboxkrnl::ExReadWriteRefurbInfo
(
	PVOID	Unknown1,
	DWORD	Unknown2,
	DWORD	Unknown3
)
{
	EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): ExReadWriteRefurbInfo\n"
           "(\n"
           "   Unknown1            : 0x%.08X\n"
           "   Unknown2            : 0x%.08X\n"
           "   Unknown3            : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), Unknown1, Unknown2, Unknown3);

	// TODO: What does this do?
	EmuWarning( "ExReadWriteRefurbInfo ignored!" );

	EmuSwapFS();	// Xbox FS

	return STATUS_SUCCESS;
}

// ******************************************************************
// * 0x001D - ExSaveNonVolatileSetting
// ******************************************************************
XBSYSAPI EXPORTNUM(29) xboxkrnl::NTSTATUS NTAPI xboxkrnl::ExSaveNonVolatileSetting
(
    IN  DWORD               ValueIndex,
    OUT DWORD              *Type,
    IN  PUCHAR              Value,
    IN  SIZE_T              ValueLength
)
{
	EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): ExSaveNonVolatileSetting\n"
           "(\n"
           "   ValueIndex          : 0x%.08X\n"
           "   Type                : 0x%.08X\n"
           "   Value               : 0x%.08X\n"
           "   ValueLength         : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), ValueIndex, Type, Value, ValueLength);

	// TODO: Later.

	EmuSwapFS();	// Xbox FS

	return STATUS_SUCCESS;
}

// ******************************************************************
// * 0x0025 - FscSetCacheSize
// ******************************************************************
XBSYSAPI EXPORTNUM(37) xboxkrnl::LONG NTAPI xboxkrnl::FscSetCacheSize(ULONG uCachePages)
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): FscSetCacheSize\n"
           "(\n"
           "   uCachePages         : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), uCachePages);

    EmuWarning("FscSetCacheSize is being ignored");

    EmuSwapFS();   // Xbox FS

    return 0;
}

// ******************************************************************
// * 0x002D - HalReadSMBusValue
// ******************************************************************
XBSYSAPI EXPORTNUM(45) xboxkrnl::NTSTATUS NTAPI xboxkrnl::HalReadSMBusValue
(
    IN  UCHAR               Address,
    IN  UCHAR               Command,
    IN  BOOLEAN             ReadWord,
    OUT PULONG              DataValue
)
{
	EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): HalReadSMBusValue\n"
           "(\n"
           "   Address             : 0x%.08X\n"
           "   Command             : 0x%.08X\n"
           "   ReadWord            : 0x%.08X\n"
           "   DataValue           : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), Address, Command, ReadWord, DataValue);

    if (ReadWord) {
        // Write UCHAR
    } else {
        // Write BYTE
    }

	EmuSwapFS();	// Xbox FS

	return STATUS_SUCCESS;
}


// ******************************************************************
// * 0x0031 - HalReturnToFirmware
// ******************************************************************
XBSYSAPI EXPORTNUM(49) VOID DECLSPEC_NORETURN xboxkrnl::HalReturnToFirmware
(
    RETURN_FIRMWARE Routine
)
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): HalReturnToFirmware\n"
           "(\n"
           "   Routine             : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), Routine);

	if( ReturnFirmwareFatal )
		EmuWarning("Stupid hack, lol" );
	else
		CxbxKrnlCleanup("Xbe has rebooted : HalReturnToFirmware(%d)", Routine);

	EmuSwapFS(); // Xbox FS
}

// ******************************************************************
// * 0x0032 - HalWriteSMBusValue
// ******************************************************************
XBSYSAPI EXPORTNUM(50) xboxkrnl::NTSTATUS NTAPI xboxkrnl::HalWriteSMBusValue
(
    IN  UCHAR               Address,
    IN  UCHAR               Command,
    IN  BOOLEAN             WriteWord,
    IN  ULONG               DataValue
)
{
	EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): HalWriteSMBusValue\n"
           "(\n"
           "   Address             : 0x%.08X\n"
           "   Command             : 0x%.08X\n"
           "   WriteWord           : 0x%.08X\n"
           "   DataValue           : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), Address, Command, WriteWord, DataValue);

	// TODO: Later.

	EmuSwapFS();	// Xbox FS

	return STATUS_SUCCESS;
}

// ******************************************************************
// * 0x0042 - IoCreateFile
// ******************************************************************
XBSYSAPI EXPORTNUM(66) xboxkrnl::NTSTATUS NTAPI xboxkrnl::IoCreateFile
(
    OUT PHANDLE             FileHandle,
    IN  ACCESS_MASK         DesiredAccess,
    IN  POBJECT_ATTRIBUTES  ObjectAttributes,
    OUT PIO_STATUS_BLOCK    IoStatusBlock,
    IN  PLARGE_INTEGER      AllocationSize,
    IN  ULONG               FileAttributes,
    IN  ULONG               ShareAccess,
    IN  ULONG               Disposition,
    IN  ULONG               CreateOptions,
    IN  ULONG               Options
)
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): IoCreateFile\n"
           "(\n"
           "   FileHandle          : 0x%.08X\n"
           "   DesiredAccess       : 0x%.08X\n"
           "   ObjectAttributes    : 0x%.08X (%s)\n"
           "   IoStatusBlock       : 0x%.08X\n"
           "   AllocationSize      : 0x%.08X\n"
           "   FileAttributes      : 0x%.08X\n"
           "   ShareAccess         : 0x%.08X\n"
           "   Disposition         : 0x%.08X\n"
           "   CreateOptions       : 0x%.08X\n"
           "   Options             : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), FileHandle, DesiredAccess, ObjectAttributes, ObjectAttributes->ObjectName->Buffer,
           IoStatusBlock, AllocationSize, FileAttributes, ShareAccess, Disposition, CreateOptions, Options);

    NTSTATUS ret = STATUS_SUCCESS;

    // TODO: Try redirecting to NtCreateFile if this function ever is run into
    CxbxKrnlCleanup("IoCreateFile not implemented");

    EmuSwapFS();   // Xbox FS

    return ret;
}

// ******************************************************************
// * 0x0043 IoCreateSymbolicLink
// ******************************************************************
XBSYSAPI EXPORTNUM(67) xboxkrnl::NTSTATUS NTAPI xboxkrnl::IoCreateSymbolicLink
(
    IN PSTRING SymbolicLinkName,
    IN PSTRING DeviceName
)
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): IoCreateSymbolicLink\n"
           "(\n"
           "   SymbolicLinkName    : 0x%.08X (%s)\n"
           "   DeviceName          : 0x%.08X (%s)\n"
           ");\n",
           GetCurrentThreadId(), SymbolicLinkName, SymbolicLinkName->Buffer,
           DeviceName, DeviceName->Buffer);

    // TODO: Actually um...implement this function
    NTSTATUS ret = STATUS_OBJECT_NAME_COLLISION;

    EmuSwapFS();   // Xbox FS

    return ret;
}

// ******************************************************************
// * 0x0045 - IoDeleteSymbolicLink
// ******************************************************************
XBSYSAPI EXPORTNUM(69) xboxkrnl::NTSTATUS NTAPI xboxkrnl::IoDeleteSymbolicLink
(
    IN PSTRING SymbolicLinkName
)
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): IoDeleteSymbolicLink\n"
           "(\n"
           "   SymbolicLinkName    : 0x%.08X (%s)\n"
           ");\n",
           GetCurrentThreadId(), SymbolicLinkName, SymbolicLinkName->Buffer);

    // TODO: Actually um...implement this function
    NTSTATUS ret = STATUS_OBJECT_NAME_NOT_FOUND;

    EmuSwapFS();   // Xbox FS

    return ret;
}

// ******************************************************************
// * IoDismountVolumeByName
// ******************************************************************
XBSYSAPI EXPORTNUM(91) xboxkrnl::NTSTATUS NTAPI xboxkrnl::IoDismountVolumeByName
(
	IN PSTRING VolumeName
)
{
	EmuSwapFS();	// Win2k/XP FS

	DbgPrintf("EmuKrnl (0x%X): IoDismountVolumeByName\n"
			"(\n"
			"   VolumeName        : 0x%.08X (%s)\n"
			");\n",
			GetCurrentThreadId(), VolumeName, VolumeName);

	// TODO: Anything?
	NTSTATUS ret = STATUS_SUCCESS;

	EmuSwapFS();	// Xbox FS

	return ret;
}

// ******************************************************************
// * KeBugCheck
// ******************************************************************
XBSYSAPI EXPORTNUM(95) VOID NTAPI xboxkrnl::KeBugCheck
(
	IN ULONG BugCheckMode
)
{
	EmuSwapFS();	// Win2k/XP FS

	DbgPrintf("EmuKrnl (0x%X): KeBugCheck\n"
			"(\n"
			"   BugCheckMode      : 0x%.08X\n"
			");\n",
			GetCurrentThreadId(), BugCheckMode);

	// TODO: Investigate XapiFiberStartup maybe?

	EmuSwapFS();	// Xbox FS
}

// ******************************************************************
// * 0x0063 - KeDelayExecutionThread
// ******************************************************************
XBSYSAPI EXPORTNUM(99) xboxkrnl::NTSTATUS NTAPI xboxkrnl::KeDelayExecutionThread
(
    IN KPROCESSOR_MODE  WaitMode,
    IN BOOLEAN          Alertable,
    IN PLARGE_INTEGER   Interval
)
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): KeDelayExecutionThread\n"
           "(\n"
           "   WaitMode            : 0x%.08X\n"
           "   Alertable           : 0x%.08X\n"
           "   Interval            : 0x%.08X (%I64d)\n"
           ");\n",
           GetCurrentThreadId(), WaitMode, Alertable, Interval, Interval == 0 ? 0 : Interval->QuadPart);

    NTSTATUS ret = NtDll::NtDelayExecution(Alertable, (NtDll::LARGE_INTEGER*)Interval);

    EmuSwapFS();   // Xbox FS

    return ret;
}

// ******************************************************************
// * 0x006B - KeInitializeDpc
// ******************************************************************
XBSYSAPI EXPORTNUM(107) VOID NTAPI xboxkrnl::KeInitializeDpc
(
    KDPC                *Dpc,
    PKDEFERRED_ROUTINE   DeferredRoutine,
    PVOID                DeferredContext
)
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): KeInitializeDpc\n"
           "(\n"
           "   Dpc                 : 0x%.08X\n"
           "   DeferredRoutine     : 0x%.08X\n"
           "   DeferredContext     : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), Dpc, DeferredRoutine, DeferredContext);

    // inialize Dpc field values
    Dpc->DeferredRoutine = DeferredRoutine;
    Dpc->Type = DpcObject;
    Dpc->DeferredContext = DeferredContext;
    Dpc->Inserted = FALSE;

    EmuSwapFS();   // Xbox FS

    return;
}

// ******************************************************************
// * 0x0071 - KeInitializeTimerEx
// ******************************************************************
XBSYSAPI EXPORTNUM(113) VOID NTAPI xboxkrnl::KeInitializeTimerEx
(
    IN PKTIMER      Timer,
    IN TIMER_TYPE   Type
)
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): KeInitializeTimerEx\n"
           "(\n"
           "   Timer               : 0x%.08X\n"
           "   Type                : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), Timer, Type);

    Timer->Header.Type               = Type + 8;  // 8 = TimerNotificationObject 
    Timer->Header.Inserted           = 0;
    Timer->Header.Size               = sizeof(KTIMER) / sizeof(ULONG);
    Timer->Header.SignalState        = 0;

    Timer->TimerListEntry.Blink      = NULL;
    Timer->TimerListEntry.Flink      = NULL;
    Timer->Header.WaitListHead.Flink = &Timer->Header.WaitListHead;
    Timer->Header.WaitListHead.Blink = &Timer->Header.WaitListHead;

    Timer->DueTime.QuadPart          = 0;
    Timer->Period                    = 0;

    EmuSwapFS();   // Xbox FS

    return;
}

// ******************************************************************
// * KeQueryPerformanceCounter
// ******************************************************************
XBSYSAPI EXPORTNUM(126) xboxkrnl::ULONGLONG NTAPI xboxkrnl::KeQueryPerformanceCounter()
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): KeQueryPerformanceCounter();\n", GetCurrentThreadId());

    ::LARGE_INTEGER Counter;

    QueryPerformanceCounter(&Counter);

    EmuSwapFS();   // Xbox FS

    return Counter.QuadPart;
}

// ******************************************************************
// * KeQueryPerformanceFrequency
// ******************************************************************
XBSYSAPI EXPORTNUM(127) xboxkrnl::ULONGLONG NTAPI xboxkrnl::KeQueryPerformanceFrequency()
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): KeQueryPerformanceFrequency();\n", GetCurrentThreadId());

    // Xbox Performance Counter Frequency := 337F98h
    ::LARGE_INTEGER Frequency;

    QueryPerformanceFrequency(&Frequency);

    EmuSwapFS();   // Xbox FS

    return Frequency.QuadPart;
}

// ******************************************************************
// * 0x0080 - KeQuerySystemTime
// ******************************************************************
XBSYSAPI EXPORTNUM(128) VOID NTAPI xboxkrnl::KeQuerySystemTime
(
    PLARGE_INTEGER CurrentTime
)
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): KeQuerySystemTime\n"
           "(\n"
           "   CurrentTime         : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), CurrentTime);

    // TODO: optimize for WinXP if speed ever becomes important here

    SYSTEMTIME SystemTime;

    GetSystemTime(&SystemTime);

    SystemTimeToFileTime(&SystemTime, (FILETIME*)CurrentTime);

    EmuSwapFS();   // Xbox FS

    return;
}

// ******************************************************************
// * KeRaiseIrqlToDpcLevel
// ******************************************************************
XBSYSAPI EXPORTNUM(129) xboxkrnl::UCHAR NTAPI xboxkrnl::KeRaiseIrqlToDpcLevel()
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): KeRaiseIrqlToDpcLevel()\n", GetCurrentThreadId());

	// I really tried to avoid adding this...
//	__asm int 3;
//	CxbxKrnlCleanup("KeRaiseIrqlToDpcLevel not implemented! (Tell blueshogun -_-)");

	EmuSwapFS();

	return 0;
}

// ******************************************************************
// * 0x0095 - KeSetTimer
// ******************************************************************
XBSYSAPI EXPORTNUM(149) xboxkrnl::BOOLEAN NTAPI xboxkrnl::KeSetTimer
(
    IN PKTIMER        Timer,
    IN LARGE_INTEGER  DueTime,
    IN PKDPC          Dpc OPTIONAL
)
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): KeSetTimer\n"
           "(\n"
           "   Timer               : 0x%.08X\n"
           "   DueTime             : 0x%.16X\n"
           "   Dpc                 : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), Timer, DueTime.QuadPart, Dpc);

    // Call KeSetTimerEx with a period of zero
    BOOLEAN bRet = KeSetTimerEx(Timer, DueTime, 0, Dpc);

    EmuSwapFS();   // Xbox FS

    return bRet;
}

// ******************************************************************
// * 0x0096 - KeSetTimerEx
// ******************************************************************
XBSYSAPI EXPORTNUM(150) xboxkrnl::BOOLEAN NTAPI xboxkrnl::KeSetTimerEx
(
    IN PKTIMER        Timer,
    IN LARGE_INTEGER  DueTime,
    IN LONG           Period OPTIONAL,
    IN PKDPC          Dpc OPTIONAL
)
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): KeSetTimerEx\n"
           "(\n"
           "   Timer               : 0x%.08X\n"
           "   DueTime             : 0x%.16X\n"
           "   Period              : 0x%.08X\n"
           "   Dpc                 : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), Timer, DueTime.QuadPart, Period, Dpc);

    BOOLEAN Inserted;
    LARGE_INTEGER Interval;
    LARGE_INTEGER SystemTime;

    #define RemoveEntryList(e) do { PLIST_ENTRY f = (e)->Flink, b = (e)->Blink; f->Blink = b; b->Flink = f; (e)->Flink = (e)->Blink = NULL; } while (0)

    if (Timer->Header.Type != 8 && Timer->Header.Type != 9) {
        CxbxKrnlCleanup("Assertion: '(Timer)->Header.Type == TimerNotificationObject) || ((Timer)->Header.Type == TimerSynchronizationObject)' in KeSetTimerEx()");
    }

    Inserted = Timer->Header.Inserted;
    if (Inserted != FALSE) {
        // Do some unlinking if already inserted in the linked list
        Timer->Header.Inserted = FALSE;
        RemoveEntryList(&Timer->TimerListEntry);
    }

    Timer->Header.SignalState = FALSE;
    Timer->Dpc = Dpc;
    Timer->Period = Period;

    if (/*!KiInsertTreeTimer(Timer,DueTime)*/ TRUE) {
        if (Timer->Header.WaitListHead.Flink != &Timer->Header.WaitListHead) {
            // KiWaitTest(Timer, 0);
        }

        if (Dpc != NULL) {
            // Call the Dpc routine if one is specified
            KeQuerySystemTime(&SystemTime);
            // Need to implement KeInsertQueueDpc xboxkrnl.exe export (ordinal 119)
            // KeInsertQueueDpc(Timer->Dpc, SystemTime.LowPart, SystemTime.HighPart);
        }

        if (Period != 0) {
            // Prepare the repetition if Timer is periodic
            Interval.QuadPart = (-10 * 1000) * Timer->Period;
            while (/*!KiInsertTreeTimer(Timer,Interval)*/TRUE) {
                ;
            }
        }
    }

    EmuSwapFS();   // Xbox FS

    return Inserted;
}

// ******************************************************************
// * 0x009C - KeTickCount
// ******************************************************************
XBSYSAPI EXPORTNUM(156) volatile xboxkrnl::DWORD xboxkrnl::KeTickCount = 0;

// ******************************************************************
// * xLaunchDataPage (pointed to by LaunchDataPage)
// ******************************************************************
LAUNCH_DATA_PAGE xLaunchDataPage =
{
    {   // header
        2,  // 2: dashboard, 0: title
        0,
        "D:\\default.xbe",
        0
    }
};

// ******************************************************************
// * 0x00A0 - KfRaiseIrql
// ******************************************************************
XBSYSAPI EXPORTNUM(160) xboxkrnl::UCHAR NTAPI xboxkrnl::KfRaiseIrql
(
    IN UCHAR NewIrql
)
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): KfRaiseIrql\n"
           "(\n"
           "   NewIrql            : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), NewIrql);

    EmuSwapFS();   // Xbox FS

    return 0;
}

// ******************************************************************
// * 0x00A1 - KfLowerIrql
// ******************************************************************
XBSYSAPI EXPORTNUM(161) xboxkrnl::UCHAR NTAPI xboxkrnl::KfLowerIrql
(
    IN UCHAR NewIrql
)
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): KfLowerIrql\n"
           "(\n"
           "   NewIrql            : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), NewIrql);

    EmuSwapFS();   // Xbox FS

    return 0;
}

// ******************************************************************
// * 0x00A4 - LaunchDataPage (actually a pointer)
// ******************************************************************
XBSYSAPI EXPORTNUM(164) xboxkrnl::PLAUNCH_DATA_PAGE xboxkrnl::LaunchDataPage = &xLaunchDataPage;

// ******************************************************************
// * 0x00A5 - MmAllocateContiguousMemory
// ******************************************************************
XBSYSAPI EXPORTNUM(165) xboxkrnl::PVOID NTAPI xboxkrnl::MmAllocateContiguousMemory
(
    IN ULONG NumberOfBytes
)
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): MmAllocateContiguousMemory\n"
           "(\n"
           "   NumberOfBytes            : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), NumberOfBytes);

    //
    // NOTE: Kludgey (but necessary) solution:
    //
    // Since this memory must be aligned on a page boundary, we must allocate an extra page
    // so that we can return a valid page aligned pointer
    //

    PVOID pRet = CxbxMalloc(NumberOfBytes + 0x1000);

    // align to page boundary
    {
        DWORD dwRet = (DWORD)pRet;

        dwRet += 0x1000 - dwRet%0x1000;

        g_AlignCache.insert(dwRet, pRet);

        pRet = (PVOID)dwRet;
    }

    DbgPrintf("EmuKrnl (0x%X): MmAllocateContiguous returned 0x%.08X\n", GetCurrentThreadId(), pRet);

    EmuSwapFS();   // Xbox FS

    return pRet;
}

// ******************************************************************
// * 0x00A6 - MmAllocateContiguousMemoryEx
// ******************************************************************
XBSYSAPI EXPORTNUM(166) xboxkrnl::PVOID NTAPI xboxkrnl::MmAllocateContiguousMemoryEx
(
    IN ULONG            NumberOfBytes,
    IN PHYSICAL_ADDRESS LowestAcceptableAddress,
    IN PHYSICAL_ADDRESS HighestAcceptableAddress,
    IN ULONG            Alignment OPTIONAL,
    IN ULONG            ProtectionType
)
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): MmAllocateContiguousMemoryEx\n"
           "(\n"
           "   NumberOfBytes            : 0x%.08X\n"
           "   LowestAcceptableAddress  : 0x%.08X\n"
           "   HighestAcceptableAddress : 0x%.08X\n"
           "   Alignment                : 0x%.08X\n"
           "   ProtectionType           : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), NumberOfBytes, LowestAcceptableAddress, HighestAcceptableAddress,
           Alignment, ProtectionType);

    //
    // NOTE: Kludgey (but necessary) solution:
    //
    // Since this memory must be aligned on a page boundary, we must allocate an extra page
    // so that we can return a valid page aligned pointer
    //

    PVOID pRet = CxbxMalloc(NumberOfBytes + 0x1000);

    // align to page boundary
    {
        DWORD dwRet = (DWORD)pRet;

        dwRet += 0x1000 - dwRet%0x1000;

        g_AlignCache.insert(dwRet, pRet);

        pRet = (PVOID)dwRet;
    }

    static int count = 0;

    if(count++ < 4)
        g_HaloHack[count-1] = (uint32)pRet;

    DbgPrintf("EmuKrnl (0x%X): MmAllocateContiguousEx returned 0x%.08X\n", GetCurrentThreadId(), pRet);

    EmuSwapFS();   // Xbox FS

    return pRet;
}

// ******************************************************************
// * 0x00A7 - MmAllocateSystemMemory
// ******************************************************************
XBSYSAPI EXPORTNUM(167) xboxkrnl::PVOID NTAPI xboxkrnl::MmAllocateSystemMemory
(
    ULONG NumberOfBytes,
    ULONG Protect
)
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): MmAllocateContiguousMemoryEx\n"
           "(\n"
           "   NumberOfBytes            : 0x%.08X\n"
           "   Protect                  : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), NumberOfBytes, Protect);

    // TODO: should this be aligned?
    PVOID pRet = CxbxMalloc(NumberOfBytes);

    EmuSwapFS();   // Xbox FS

    return pRet;
}

// ******************************************************************
// * 0x00A9 - MmCreateKernelStack
// ******************************************************************
// * Differences from NT: Custom stack size.
// ******************************************************************
XBSYSAPI EXPORTNUM(169) xboxkrnl::PVOID NTAPI xboxkrnl::MmCreateKernelStack
(
    IN ULONG	NumberOfBytes,
    IN BOOLEAN  DebuggerThread
)
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): MmCreateKernelStack\n"
           "(\n"
           "   NumberOfBytes            : 0x%.08X\n"
           "   DebuggerThread           : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), NumberOfBytes, DebuggerThread);
	
	NtDll::PVOID pRet = NULL;

    if (!NumberOfBytes) {
        // NumberOfBytes cannot be zero when passed to NtAllocateVirtualMemory() below
        CxbxKrnlCleanup("Assertion: 'NumberOfBytes != 0' in MmCreateKernelStack()");
    }

    if (NumberOfBytes & 0xFF) {
        // Validate NumberOfBytes for alignment with the page size
        CxbxKrnlCleanup("Assertion: '(NumberOfBytes & (PAGE_SIZE -1)) == 0' in MmCreateKernelStack()");
    }

    /**
     * Function at present does not:
     * - Create an additional guard PAGE_SIZE after allocation,
     * - Fill allocation with any values
     * - Treat DebuggerThread any differently
     */

	if(FAILED(NtDll::NtAllocateVirtualMemory(GetCurrentProcess(), &pRet, 0, &NumberOfBytes, MEM_COMMIT, PAGE_READWRITE)))
	    EmuWarning("MmCreateKernelStack failed!\n");
	else
		pRet = (PVOID)((ULONG)pRet + NumberOfBytes);

    EmuSwapFS();   // Xbox FS

    return pRet;
}

// ******************************************************************
// * 0x00AA - MmDeleteKernelStack
// ******************************************************************
XBSYSAPI EXPORTNUM(170) VOID NTAPI xboxkrnl::MmDeleteKernelStack
(
    PVOID EndAddress,
    PVOID BaseAddress
)
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): MmDeleteKernelStack\n"
           "(\n"
           "   EndAddress               : 0x%.08X\n"
           "   BaseAddress              : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), EndAddress, BaseAddress);

   /* __asm int 3;
	CxbxKrnlCleanup( "MmDeleteKernelStack unimplemented (check call stack)" );*/
	ULONG RegionSize = 0;
    if (FAILED(NtDll::NtFreeVirtualMemory(GetCurrentProcess(), &BaseAddress, &RegionSize, MEM_RELEASE)))
        EmuWarning("MmDeleteKernelStack failed!\n");

    EmuSwapFS();   // Xbox FS
}

// ******************************************************************
// * 0x00AB - MmFreeContiguousMemory
// ******************************************************************
XBSYSAPI EXPORTNUM(171) VOID NTAPI xboxkrnl::MmFreeContiguousMemory
(
    IN PVOID BaseAddress
)
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): MmFreeContiguousMemory\n"
           "(\n"
           "   BaseAddress              : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), BaseAddress);

    PVOID OrigBaseAddress = BaseAddress;

    if(g_AlignCache.exists(BaseAddress))
    {
        OrigBaseAddress = g_AlignCache.get(BaseAddress);

        g_AlignCache.remove(BaseAddress);
    }

    if(OrigBaseAddress != &xLaunchDataPage)
    {
        CxbxFree(OrigBaseAddress);
    }
    else
    {
        DbgPrintf("Ignored MmFreeContiguousMemory(&xLaunchDataPage)\n");
    }

    EmuSwapFS();   // Xbox FS

    return;
}

// ******************************************************************
// * 0x00AC - MmFreeSystemMemory
// ******************************************************************
XBSYSAPI EXPORTNUM(172) xboxkrnl::NTSTATUS NTAPI xboxkrnl::MmFreeSystemMemory
(
    PVOID BaseAddress,
    ULONG NumberOfBytes
)
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): MmFreeSystemMemory\n"
           "(\n"
           "   BaseAddress              : 0x%.08X\n"
           "   NumberOfBytes            : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), BaseAddress, NumberOfBytes);

    CxbxFree(BaseAddress);

    EmuSwapFS();   // Xbox FS

    return STATUS_SUCCESS;
}

// ******************************************************************
// * 0x00B1 - MmMapIoSpace
// ******************************************************************
XBSYSAPI EXPORTNUM(177) xboxkrnl::PVOID NTAPI xboxkrnl::MmMapIoSpace
(
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN ULONG            NumberOfBytes,
    IN ULONG            ProtectionType
)
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): MmMapIoSpace\n"
           "(\n"
           "   PhysicalAddress          : 0x%.08X\n"
           "   NumberOfBytes            : 0x%.08X\n"
           "   ProtectionType           : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), PhysicalAddress, NumberOfBytes, ProtectionType);

    // TODO: should this be aligned?
    PVOID pRet = CxbxMalloc(NumberOfBytes);

    EmuSwapFS();   // Xbox FS

    return pRet;
}

// ******************************************************************
// * 0x00B2 - MmPersistContiguousMemory
// ******************************************************************
XBSYSAPI EXPORTNUM(178) VOID NTAPI xboxkrnl::MmPersistContiguousMemory
(
    IN PVOID   BaseAddress,
    IN ULONG   NumberOfBytes,
    IN BOOLEAN Persist
)
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): MmPersistContiguousMemory\n"
           "(\n"
           "   BaseAddress              : 0x%.08X\n"
           "   NumberOfBytes            : 0x%.08X\n"
           "   Persist                  : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), BaseAddress, NumberOfBytes, Persist);

    // TODO: Actually set this up to be remember across a "reboot"
    EmuWarning("MmPersistContiguousMemory is being ignored\n");

    EmuSwapFS();   // Xbox FS
}

// ******************************************************************
// * 0x00B4 - MmQueryAllocationSize
// ******************************************************************
XBSYSAPI EXPORTNUM(180) XTL::ULONG NTAPI xboxkrnl::MmQueryAllocationSize
(
    IN PVOID   BaseAddress
)
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): MmQueryAllocationSize\n"
           "(\n"
           "   BaseAddress              : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), BaseAddress);

    ULONG uiSize = EmuCheckAllocationSize(BaseAddress, false);

    EmuSwapFS();   // Xbox FS

    return uiSize;
}

// ******************************************************************
// * 0x00B5 - MmQueryStatistics
// ******************************************************************
XBSYSAPI EXPORTNUM(181) xboxkrnl::NTSTATUS NTAPI xboxkrnl::MmQueryStatistics
(
    OUT PMM_STATISTICS MemoryStatistics
)
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): MmQueryStatistics\n"
           "(\n"
           "   MemoryStatistics         : 0x%.08X (MemoryStatistics->Length = 0x%.08X)\n"
           ");\n",
           GetCurrentThreadId(), MemoryStatistics, MemoryStatistics->Length);

    MEMORYSTATUS MemoryStatus;
    SYSTEM_INFO SysInfo;
    NTSTATUS ret;

    if (MemoryStatistics->Length == 0x24)
    {
        GlobalMemoryStatus(&MemoryStatus);
        GetSystemInfo(&SysInfo);

        /** 
        * When each of the PMM_STATISTICS MemoryStatistics elements
        * are setup correctly below, these two lines become redundant 
        */
        ZeroMemory(MemoryStatistics, sizeof(MM_STATISTICS));
        MemoryStatistics->Length = sizeof(MM_STATISTICS);

        MemoryStatistics->TotalPhysicalPages = MemoryStatus.dwTotalPhys / SysInfo.dwPageSize;
        MemoryStatistics->AvailablePages = MemoryStatus.dwAvailPhys / SysInfo.dwPageSize;
        MemoryStatistics->VirtualMemoryBytesCommitted = MemoryStatus.dwTotalVirtual - MemoryStatus.dwAvailVirtual;
        MemoryStatistics->VirtualMemoryBytesReserved = MemoryStatus.dwAvailVirtual;
        // MemoryStatistics->CachePagesCommitted = [ ];
        // MemoryStatistics->PoolPagesCommitted = [ ];
        // MemoryStatistics->StackPagesCommitted = [ ];
        // MemoryStatistics->ImagePagesCommitted = [ ];

        DbgPrintf("   MemoryStatistics->Length                      = 0x%.08X\n", MemoryStatistics->Length);
        DbgPrintf("   MemoryStatistics->TotalPhysicalPages          = 0x%.08X\n", MemoryStatistics->TotalPhysicalPages);
        DbgPrintf("   MemoryStatistics->AvailablePages              = 0x%.08X\n", MemoryStatistics->AvailablePages);
        DbgPrintf("   MemoryStatistics->VirtualMemoryBytesCommitted = 0x%.08X\n", MemoryStatistics->VirtualMemoryBytesCommitted);
        DbgPrintf("   MemoryStatistics->VirtualMemoryBytesReserved  = 0x%.08X\n", MemoryStatistics->VirtualMemoryBytesReserved);
        DbgPrintf("   MemoryStatistics->CachePagesCommitted         = 0x%.08X\n", MemoryStatistics->CachePagesCommitted);
        DbgPrintf("   MemoryStatistics->PoolPagesCommitted          = 0x%.08X\n", MemoryStatistics->PoolPagesCommitted);
        DbgPrintf("   MemoryStatistics->StackPagesCommitted         = 0x%.08X\n", MemoryStatistics->StackPagesCommitted);
        DbgPrintf("   MemoryStatistics->ImagePagesCommitted         = 0x%.08X\n", MemoryStatistics->ImagePagesCommitted);

        ret = STATUS_SUCCESS;
    } 
    else 
    {
        EmuWarning("EmuKrnl (0x%X): MmQueryStatistics with unusual size -> 0x%.08X\n", GetCurrentThreadId(), MemoryStatistics->Length);
        ret = STATUS_INVALID_PARAMETER;
    }

    EmuSwapFS();   // Xbox FS

    return ret;
}

// ******************************************************************
// * 0x00B6 - MmSetAddressProtect
// ******************************************************************
XBSYSAPI EXPORTNUM(182) VOID NTAPI xboxkrnl::MmSetAddressProtect
(
    IN PVOID BaseAddress,
    IN ULONG NumberOfBytes,
    IN ULONG NewProtect
)
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): MmSetAddressProtect\n"
           "(\n"
           "   BaseAddress              : 0x%.08X\n"
           "   NumberOfBytes            : 0x%.08X\n"
           "   NewProtect               : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), BaseAddress, NumberOfBytes, NewProtect);

    // Halo Hack
    if(BaseAddress == (PVOID)0x80366000)
    {
        BaseAddress = (PVOID)(g_HaloHack[0] + (0x80366000 - 0x80061000));

        DbgPrintf("EmuKrnl (0x%X): Halo Access Adjust 3 was applied! (0x%.08X)\n", GetCurrentThreadId(), BaseAddress);
    }

    DWORD dwOldProtect;

    if(!VirtualProtect(BaseAddress, NumberOfBytes, NewProtect & (~PAGE_WRITECOMBINE), &dwOldProtect))
        EmuWarning("VirtualProtect Failed!");

    DbgPrintf("EmuKrnl (0x%X): VirtualProtect was 0x%.08X -> 0x%.08X\n", GetCurrentThreadId(), dwOldProtect, NewProtect & (~PAGE_WRITECOMBINE));

    EmuSwapFS();   // Xbox FS

    return;
}

// ******************************************************************
// * 0x00B7 - MmUnmapIoSpace
// ******************************************************************
XBSYSAPI EXPORTNUM(183) xboxkrnl::NTSTATUS NTAPI xboxkrnl::MmUnmapIoSpace
(
    IN PVOID BaseAddress,
    IN ULONG NumberOfBytes
)
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): MmUnmapIoSpace\n"
           "(\n"
           "   BaseAddress              : 0x%.08X\n"
           "   NumberOfBytes            : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), BaseAddress, NumberOfBytes);

    CxbxFree(BaseAddress);

    EmuSwapFS();   // Xbox FS

    return STATUS_SUCCESS;
}

// ******************************************************************
// * 0x00B8 - NtAllocateVirtualMemory
// ******************************************************************
XBSYSAPI EXPORTNUM(184) xboxkrnl::NTSTATUS NTAPI xboxkrnl::NtAllocateVirtualMemory
(
    IN OUT PVOID    *BaseAddress,
    IN ULONG         ZeroBits,
    IN OUT PULONG    AllocationSize,
    IN DWORD         AllocationType,
    IN DWORD         Protect
)
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): NtAllocateVirtualMemory\n"
           "(\n"
           "   BaseAddress         : 0x%.08X (0x%.08X)\n"
           "   ZeroBits            : 0x%.08X\n"
           "   AllocationSize      : 0x%.08X (0x%.08X)\n"
           "   AllocationType      : 0x%.08X\n"
           "   Protect             : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), BaseAddress, *BaseAddress, ZeroBits, AllocationSize, *AllocationSize, AllocationType, Protect);
	
	// TODO: The flag known as MEM_NOZERO (which appears to be exclusive to Xbox) has the exact
	// same value as MEM_ROTATE which causes problems for Windows XP, but not Vista.  Removing
	// this flag fixes Azurik for XP.
	DWORD MEM_NOZERO = 0x800000;

	if( AllocationType & MEM_NOZERO )
	{
		EmuWarning( "MEM_NOZERO flag is not supported!" );
		AllocationType &= ~MEM_NOZERO;
	}

    NTSTATUS ret = NtDll::NtAllocateVirtualMemory(GetCurrentProcess(), BaseAddress, ZeroBits, AllocationSize, AllocationType, Protect);
	if( ret == 0xC00000F3 )
		EmuWarning( "Invalid Param!" );

    EmuSwapFS();   // Xbox FS

    return ret;
}

// ******************************************************************
// * 0x00BA - NtClearEvent
// ******************************************************************
XBSYSAPI EXPORTNUM(186) xboxkrnl::NTSTATUS NTAPI xboxkrnl::NtClearEvent
(
    IN HANDLE EventHandle
)
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): NtClearEvent\n"
           "(\n"
           "   EventHandle         : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), EventHandle);

    NTSTATUS ret = NtDll::NtClearEvent(EventHandle);

    if(FAILED(ret))
        EmuWarning("NtClearEvent Failed!");

    EmuSwapFS();   // Xbox FS

    return ret;
}

// ******************************************************************
// * 0x00BB - NtClose
// ******************************************************************
XBSYSAPI EXPORTNUM(187) xboxkrnl::NTSTATUS NTAPI xboxkrnl::NtClose
(
    IN HANDLE Handle
)
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): NtClose\n"
           "(\n"
           "   Handle              : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), Handle);

    NTSTATUS ret = STATUS_SUCCESS;

    // delete 'special' handles
    if(IsEmuHandle(Handle))
    {
        EmuHandle *iEmuHandle = EmuHandleToPtr(Handle);

        delete iEmuHandle;

        ret = STATUS_SUCCESS;
    }
    // close normal handles
    else
    {
        ret = NtDll::NtClose(Handle);
    }

    EmuSwapFS();   // Xbox FS

    return ret;
}

// ******************************************************************
// * 0x00BD - NtCreateEvent
// ******************************************************************
XBSYSAPI EXPORTNUM(189) xboxkrnl::NTSTATUS NTAPI xboxkrnl::NtCreateEvent
(
    OUT PHANDLE             EventHandle,
    IN  POBJECT_ATTRIBUTES  ObjectAttributes OPTIONAL,
    IN  EVENT_TYPE          EventType,
    IN  BOOLEAN             InitialState
)
{
    EmuSwapFS();   // Win2k/XP FS

    char *szBuffer = (ObjectAttributes != 0) ? ObjectAttributes->ObjectName->Buffer : 0;

    DbgPrintf("EmuKrnl (0x%X): NtCreateEvent\n"
           "(\n"
           "   EventHandle         : 0x%.08X\n"
           "   ObjectAttributes    : 0x%.08X (\"%s\")\n"
           "   EventType           : 0x%.08X\n"
           "   InitialState        : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), EventHandle, ObjectAttributes, szBuffer,
           EventType, InitialState);

    wchar_t wszObjectName[160];

    NtDll::UNICODE_STRING    NtUnicodeString;
    NtDll::OBJECT_ATTRIBUTES NtObjAttr;

    // initialize object attributes
    if(szBuffer != 0)
    {
        mbstowcs(wszObjectName, "\\??\\", 4);
        mbstowcs(wszObjectName+4, szBuffer, 160);

        NtDll::RtlInitUnicodeString(&NtUnicodeString, wszObjectName);

        InitializeObjectAttributes(&NtObjAttr, &NtUnicodeString, ObjectAttributes->Attributes, ObjectAttributes->RootDirectory, NULL);
    }

    NtObjAttr.RootDirectory = 0;

    // redirect to NtCreateEvent
    NTSTATUS ret = NtDll::NtCreateEvent(EventHandle, EVENT_ALL_ACCESS, (szBuffer != 0) ? &NtObjAttr : 0, (NtDll::EVENT_TYPE)EventType, InitialState);

    if(FAILED(ret))
        EmuWarning("NtCreateEvent Failed!");

    DbgPrintf("EmuKrnl (0x%X): NtCreateEvent EventHandle = 0x%.08X\n", GetCurrentThreadId(), *EventHandle);

    EmuSwapFS();   // Xbox FS

    return ret;
}

// ******************************************************************
// * 0x00BE - NtCreateFile
// ******************************************************************
XBSYSAPI EXPORTNUM(190) xboxkrnl::NTSTATUS NTAPI xboxkrnl::NtCreateFile
(
    OUT PHANDLE             FileHandle,
    IN  ACCESS_MASK         DesiredAccess,
    IN  POBJECT_ATTRIBUTES  ObjectAttributes,
    OUT PIO_STATUS_BLOCK    IoStatusBlock,
    IN  PLARGE_INTEGER      AllocationSize OPTIONAL,
    IN  ULONG               FileAttributes,
    IN  ULONG               ShareAccess,
    IN  ULONG               CreateDisposition,
    IN  ULONG               CreateOptions
)
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): NtCreateFile\n"
           "(\n"
           "   FileHandle          : 0x%.08X\n"
           "   DesiredAccess       : 0x%.08X\n"
           "   ObjectAttributes    : 0x%.08X (\"%s\")\n"
           "   IoStatusBlock       : 0x%.08X\n"
           "   AllocationSize      : 0x%.08X\n"
           "   FileAttributes      : 0x%.08X\n"
           "   ShareAccess         : 0x%.08X\n"
           "   CreateDisposition   : 0x%.08X\n"
           "   CreateOptions       : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), FileHandle, DesiredAccess, ObjectAttributes, ObjectAttributes->ObjectName->Buffer,
           IoStatusBlock, AllocationSize, FileAttributes, ShareAccess, CreateDisposition, CreateOptions);

    char ReplaceChar  = '\0';
    int  ReplaceIndex = -1;

    char *szBuffer = ObjectAttributes->ObjectName->Buffer;

	if(szBuffer == (char*) 0xFFFFFFFF)
		szBuffer = NULL;

    if(szBuffer != NULL)
    {
        //printf("Orig : %s\n", szBuffer);

        // trim this off
        if(szBuffer[0] == '\\' && szBuffer[1] == '?' && szBuffer[2] == '?' && szBuffer[3] == '\\')
        {
            szBuffer += 4;
        }

        // D:\ should map to current directory
        if( (szBuffer[0] == 'D' || szBuffer[0] == 'd') && szBuffer[1] == ':' && szBuffer[2] == '\\')
        {
            szBuffer += 3;

            ObjectAttributes->RootDirectory = g_hCurDir;

            DbgPrintf("EmuKrnl (0x%X): NtCreateFile Corrected path...\n", GetCurrentThreadId());
            DbgPrintf("  Org:\"%s\"\n", ObjectAttributes->ObjectName->Buffer);
            DbgPrintf("  New:\"$XbePath\\%s\"\n", szBuffer);
        }
		// Going to map Y:\ to current directory as well (dashboard test, 3944)
        else if( (szBuffer[0] == 'Y' || szBuffer[0] == 'y') && szBuffer[1] == ':' && szBuffer[2] == '\\')
        {
            szBuffer += 3;

            ObjectAttributes->RootDirectory = g_hCurDir;

            DbgPrintf("EmuKrnl (0x%X): NtCreateFile Corrected path...\n", GetCurrentThreadId());
            DbgPrintf("  Org:\"%s\"\n", ObjectAttributes->ObjectName->Buffer);
            DbgPrintf("  New:\"$XbePath\\%s\"\n", szBuffer);
        }
        else if( (szBuffer[0] == 'T' || szBuffer[0] == 't') && szBuffer[1] == ':' && szBuffer[2] == '\\')
        {
            szBuffer += 3;

            ObjectAttributes->RootDirectory = g_hTDrive;

            DbgPrintf("EmuKrnl (0x%X): NtCreateFile Corrected path...\n", GetCurrentThreadId());
            DbgPrintf("  Org:\"%s\"\n", ObjectAttributes->ObjectName->Buffer);
            DbgPrintf("  New:\"$CxbxPath\\EmuDisk\\T\\%s\"\n", szBuffer);
        }
        else if( (szBuffer[0] == 'U' || szBuffer[0] == 'u') && szBuffer[1] == ':' && szBuffer[2] == '\\')
        {
            szBuffer += 3;

            ObjectAttributes->RootDirectory = g_hUDrive;

            DbgPrintf("EmuKrnl (0x%X): NtCreateFile Corrected path...\n", GetCurrentThreadId());
            DbgPrintf("  Org:\"%s\"\n", ObjectAttributes->ObjectName->Buffer);
            DbgPrintf("  New:\"$CxbxPath\\EmuDisk\\U\\%s\"\n", szBuffer);
        }
        else if( (szBuffer[0] == 'Z' || szBuffer[0] == 'z') && szBuffer[1] == ':' && szBuffer[2] == '\\')
        {
            szBuffer += 3;

            ObjectAttributes->RootDirectory = g_hZDrive;

            DbgPrintf("EmuKrnl (0x%X): NtCreateFile Corrected path...\n", GetCurrentThreadId());
            DbgPrintf("  Org:\"%s\"\n", ObjectAttributes->ObjectName->Buffer);
            DbgPrintf("  New:\"$CxbxPath\\EmuDisk\\Z\\%s\"\n", szBuffer);
        }

        // Ignore wildcards. Xapi FindFirstFile uses the same path buffer for
        // NtOpenFile and NtQueryDirectoryFile. Wildcards are only parsed by
        // the latter.
        {
            for(int v=0;szBuffer[v] != '\0';v++)
            {
                // FIXME: Fallback to parent directory if wildcard is found.
                if(szBuffer[v] == '*')
                {
                    ReplaceIndex = v;
                    break;
                }
            }
        }

        // Note: Hack: Not thread safe (if problems occur, create a temp buffer)
        if(ReplaceIndex != -1)
		{
            ReplaceChar = szBuffer[ReplaceIndex];
            szBuffer[ReplaceIndex] = '\0';
        }

        //printf("Aftr : %s\n", szBuffer);
    }

    wchar_t wszObjectName[160];

    NtDll::UNICODE_STRING    NtUnicodeString;
    NtDll::OBJECT_ATTRIBUTES NtObjAttr;

    // initialize object attributes
    if(szBuffer != NULL)
    {
        mbstowcs(wszObjectName, szBuffer, 160);
    }
    else
    {
        wszObjectName[0] = L'\0';
    }

    NtDll::RtlInitUnicodeString(&NtUnicodeString, wszObjectName);

    InitializeObjectAttributes(&NtObjAttr, &NtUnicodeString, ObjectAttributes->Attributes, ObjectAttributes->RootDirectory, NULL);

    // redirect to NtCreateFile
    NTSTATUS ret = NtDll::NtCreateFile
    (
        FileHandle, DesiredAccess, &NtObjAttr, (NtDll::IO_STATUS_BLOCK*)IoStatusBlock,
        (NtDll::LARGE_INTEGER*)AllocationSize, FileAttributes, ShareAccess, CreateDisposition, CreateOptions, NULL, 0
    );

    // If we're trying to open a regular file as a directory, fallback to
    // parent directory. This behavior is required by Xapi FindFirstFile.
    if(ret == STATUS_NOT_A_DIRECTORY)
    {
        DbgPrintf("EmuKrnl (0x%X): NtCreateFile fallback to parent directory\n", GetCurrentThreadId());

        // Restore original buffer.
        if(ReplaceIndex != -1)
        {
            szBuffer[ReplaceIndex] = ReplaceChar;
        }

        // Strip filename from path.
        int CurIndex = strlen(szBuffer);
        while(CurIndex--)
        {
            if(szBuffer[CurIndex] == '\\')
            {
                ReplaceIndex = CurIndex;
                break;
            }
        }
        if(CurIndex == -1)
        {
            ReplaceIndex = 0;
        }

        // Modify buffer again.
        ReplaceChar = szBuffer[ReplaceIndex];
        szBuffer[ReplaceIndex] = '\0';
        DbgPrintf("  New:\"$CurRoot\\%s\"\n", szBuffer);

        mbstowcs(wszObjectName, szBuffer, 160);
        NtDll::RtlInitUnicodeString(&NtUnicodeString, wszObjectName);

        ret = NtDll::NtCreateFile
        (
            FileHandle, DesiredAccess, &NtObjAttr, (NtDll::IO_STATUS_BLOCK*)IoStatusBlock,
            (NtDll::LARGE_INTEGER*)AllocationSize, FileAttributes, ShareAccess, CreateDisposition, CreateOptions, NULL, 0
        );
    }

    if(FAILED(ret))
    {
        DbgPrintf("EmuKrnl (0x%X): NtCreateFile Failed! (0x%.08X)\n", GetCurrentThreadId(), ret);
    }
    else
    {
        DbgPrintf("EmuKrnl (0x%X): NtCreateFile = 0x%.08X\n", GetCurrentThreadId(), *FileHandle);
    }

    // restore original buffer
    if(ReplaceIndex != -1)
    {
        szBuffer[ReplaceIndex] = ReplaceChar;
    }

    // NOTE: We can map this to IoCreateFile once implemented (if ever necessary)
    //       xboxkrnl::IoCreateFile(FileHandle, DesiredAccess, ObjectAttributes, IoStatusBlock, AllocationSize, FileAttributes, ShareAccess, CreateDisposition, CreateOptions, 0);

    EmuSwapFS();   // Xbox FS

    return ret;
}

// ******************************************************************
// * 0x00C0 - NtCreateMutant
// ******************************************************************
XBSYSAPI EXPORTNUM(192) xboxkrnl::NTSTATUS NTAPI xboxkrnl::NtCreateMutant
(
    OUT PHANDLE             MutantHandle,
    IN  POBJECT_ATTRIBUTES  ObjectAttributes,
    IN  BOOLEAN             InitialOwner
)
{
    EmuSwapFS();   // Win2k/XP FS

    char *szBuffer = (ObjectAttributes != 0) ? ObjectAttributes->ObjectName->Buffer : 0;

    DbgPrintf("EmuKrnl (0x%X): NtCreateMutant\n"
           "(\n"
           "   MutantHandle        : 0x%.08X\n"
           "   ObjectAttributes    : 0x%.08X (\"%s\")\n"
           "   InitialOwner        : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), MutantHandle, ObjectAttributes, szBuffer, InitialOwner);

    wchar_t wszObjectName[160];

    NtDll::UNICODE_STRING    NtUnicodeString;
    NtDll::OBJECT_ATTRIBUTES NtObjAttr;

    // initialize object attributes
    if(szBuffer != 0)
    {
        mbstowcs(wszObjectName, "\\??\\", 4);
        mbstowcs(wszObjectName+4, szBuffer, 160);

        NtDll::RtlInitUnicodeString(&NtUnicodeString, wszObjectName);

        InitializeObjectAttributes(&NtObjAttr, &NtUnicodeString, ObjectAttributes->Attributes, ObjectAttributes->RootDirectory, NULL);
    }

    NtObjAttr.RootDirectory = 0;

    // redirect to NtCreateMutant
    NTSTATUS ret = NtDll::NtCreateMutant(MutantHandle, MUTANT_ALL_ACCESS, (szBuffer != 0) ? &NtObjAttr : 0, InitialOwner);

    if(FAILED(ret))
        EmuWarning("NtCreateMutant Failed!");

    DbgPrintf("EmuKrnl (0x%X): NtCreateMutant MutantHandle = 0x%.08X\n", GetCurrentThreadId(), *MutantHandle);

    EmuSwapFS();   // Xbox FS

    return ret;
}

// ******************************************************************
// * 0x00C1 - NtCreateSemaphore
// ******************************************************************
XBSYSAPI EXPORTNUM(193) xboxkrnl::NTSTATUS NTAPI xboxkrnl::NtCreateSemaphore
(
    OUT PHANDLE             SemaphoreHandle,
    IN  POBJECT_ATTRIBUTES  ObjectAttributes,
    IN  ULONG               InitialCount,
    IN  ULONG               MaximumCount
)
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): NtCreateSemaphore\n"
           "(\n"
           "   SemaphoreHandle     : 0x%.08X\n"
           "   ObjectAttributes    : 0x%.08X\n"
           "   InitialCount        : 0x%.08X\n"
           "   MaximumCount        : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), SemaphoreHandle, ObjectAttributes,
           InitialCount, MaximumCount);

    // redirect to Win2k/XP
    NTSTATUS ret = NtDll::NtCreateSemaphore
    (
        SemaphoreHandle,
        SEMAPHORE_ALL_ACCESS,
        (NtDll::POBJECT_ATTRIBUTES)ObjectAttributes,
        InitialCount,
        MaximumCount
    );

    if(FAILED(ret))
        EmuWarning("NtCreateSemaphore failed!");

    DbgPrintf("EmuKrnl (0x%X): NtCreateSemaphore SemaphoreHandle = 0x%.08X\n", GetCurrentThreadId(), *SemaphoreHandle);

    EmuSwapFS();   // Xbox FS

    return ret;
}

// ******************************************************************
// * 0x00C5 - NtDuplicateObject
// ******************************************************************
XBSYSAPI EXPORTNUM(197) xboxkrnl::NTSTATUS NTAPI xboxkrnl::NtDuplicateObject
(
    HANDLE  SourceHandle,
    HANDLE *TargetHandle,
    DWORD   Options
)
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): NtDuplicateObject\n"
           "(\n"
           "   SourceHandle        : 0x%.08X\n"
           "   TargetHandle        : 0x%.08X\n"
           "   Options             : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), SourceHandle, TargetHandle, Options);

    // redirect to Win2k/XP
    NTSTATUS ret = NtDll::NtDuplicateObject
    (
        GetCurrentProcess(),
        SourceHandle,
        GetCurrentProcess(),
        TargetHandle,
        0, 0, Options
    );

    if(ret != STATUS_SUCCESS)
        EmuWarning("Object was not duplicated!");

    EmuSwapFS();   // Xbox FS

    return ret;
}

// ******************************************************************
// * NtFlushBuffersFile
// ******************************************************************
XBSYSAPI EXPORTNUM(198) xboxkrnl::NTSTATUS NTAPI xboxkrnl::NtFlushBuffersFile
(
    PVOID                FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock
)
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): NtFlushBuffersFile\n"
           "(\n"
           "   FileHandle          : 0x%.08X\n"
           "   IoStatusBlock       : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), FileHandle, IoStatusBlock);

    NTSTATUS ret = NtDll::NtFlushBuffersFile(FileHandle, (NtDll::IO_STATUS_BLOCK*)IoStatusBlock);

    EmuSwapFS();   // Xbox FS

    return ret;
}

// ******************************************************************
// * 0x00C7 - NtFreeVirtualMemory
// ******************************************************************
XBSYSAPI EXPORTNUM(199) xboxkrnl::NTSTATUS NTAPI xboxkrnl::NtFreeVirtualMemory
(
    IN OUT PVOID *BaseAddress,
    IN OUT PULONG FreeSize,
    IN ULONG      FreeType
)
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): NtFreeVirtualMemory\n"
           "(\n"
           "   BaseAddress         : 0x%.08X\n"
           "   FreeSize            : 0x%.08X\n"
           "   FreeType            : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), BaseAddress, FreeSize, FreeType);

    NTSTATUS ret = NtDll::NtFreeVirtualMemory(GetCurrentProcess(), BaseAddress, FreeSize, FreeType);

    EmuSwapFS();   // Xbox FS

    return ret;
}

// ******************************************************************
// * 0x00CA - NtOpenFile
// ******************************************************************
XBSYSAPI EXPORTNUM(202) xboxkrnl::NTSTATUS NTAPI xboxkrnl::NtOpenFile
(
    OUT PHANDLE             FileHandle,
    IN  ACCESS_MASK         DesiredAccess,
    IN  POBJECT_ATTRIBUTES  ObjectAttributes,
    OUT PIO_STATUS_BLOCK    IoStatusBlock,
    IN  ULONG               ShareAccess,
    IN  ULONG               OpenOptions
)
{
    // debug trace
    /* Redundant
    #ifdef _DEBUG_TRACE
    {
        EmuSwapFS();   // Win2k/XP FS
        DbgPrintf("EmuKrnl (0x%X): NtOpenFile\n"
               "(\n"
               "   FileHandle          : 0x%.08X\n"
               "   DesiredAccess       : 0x%.08X\n"
               "   ObjectAttributes    : 0x%.08X (\"%s\")\n"
               "   IoStatusBlock       : 0x%.08X\n"
               "   ShareAccess         : 0x%.08X\n"
               "   CreateOptions       : 0x%.08X\n"
               ");\n",
               GetCurrentThreadId(), FileHandle, DesiredAccess, ObjectAttributes, ObjectAttributes->ObjectName->Buffer,
               IoStatusBlock, ShareAccess, OpenOptions);
        EmuSwapFS();   // Xbox FS
    }
    #endif
    //*/

    return NtCreateFile(FileHandle, DesiredAccess, ObjectAttributes, IoStatusBlock, NULL, 0, ShareAccess, FILE_OPEN, OpenOptions);
}

// ******************************************************************
// * 0x00CE - NtQueueApcThread
// ******************************************************************
XBSYSAPI EXPORTNUM(206) xboxkrnl::NTSTATUS NTAPI xboxkrnl::NtQueueApcThread
(
	IN HANDLE               ThreadHandle,
	IN PIO_APC_ROUTINE      ApcRoutine,
	IN PVOID                ApcRoutineContext OPTIONAL,
	IN PIO_STATUS_BLOCK     ApcStatusBlock OPTIONAL,
	IN ULONG                ApcReserved OPTIONAL 
)
{
	EmuSwapFS();	// Win2k/XP FS

	DbgPrintf("EmuKrnl (0x%X): NtQueueApcThread\n"
           "(\n"
           "   ThreadHandle         : 0x%.08X\n"
           "   ApcRoutine           : 0x%.08X\n"
           "   ApcRoutineContext    : 0x%.08X\n"
           "   ApcStatusBlock       : 0x%.08X\n"
           "   ApcReserved          : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), ThreadHandle, ApcRoutine, ApcRoutineContext,
		   ApcStatusBlock, ApcReserved);

	NTSTATUS ret;

	// TODO: Not too sure how this one works.  If there's any special *magic* that needs to be
	//		 done, let me know!
	ret = NtDll::NtQueueApcThread( (NtDll::HANDLE) ThreadHandle, (NtDll::PIO_APC_ROUTINE) ApcRoutine, ApcRoutineContext, 
									(NtDll::PIO_STATUS_BLOCK) ApcStatusBlock, ApcReserved );
	if( FAILED( ret ) )
		EmuWarning( "NtQueueApcThread failed!" );

	EmuSwapFS();	// Xbox FS

	return ret;
}

// ******************************************************************
// * 0x00CF - NtQueryDirectoryFile
// ******************************************************************
XBSYSAPI EXPORTNUM(207) xboxkrnl::NTSTATUS NTAPI xboxkrnl::NtQueryDirectoryFile
(
    IN  HANDLE                      FileHandle,
    IN  HANDLE                      Event OPTIONAL,
    IN  PVOID                       ApcRoutine, // Todo: define this routine's prototype
    IN  PVOID                       ApcContext,
    OUT PIO_STATUS_BLOCK            IoStatusBlock,
    OUT FILE_DIRECTORY_INFORMATION *FileInformation,
    IN  ULONG                       Length,
    IN  FILE_INFORMATION_CLASS      FileInformationClass,
    IN  PSTRING                     FileMask,
    IN  BOOLEAN                     RestartScan
)
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): NtQueryDirectoryFile\n"
           "(\n"
           "   FileHandle           : 0x%.08X\n"
           "   Event                : 0x%.08X\n"
           "   ApcRoutine           : 0x%.08X\n"
           "   ApcContext           : 0x%.08X\n"
           "   IoStatusBlock        : 0x%.08X\n"
           "   FileInformation      : 0x%.08X\n"
           "   Length               : 0x%.08X\n"
           "   FileInformationClass : 0x%.08X\n"
           "   FileMask             : 0x%.08X (%s)\n"
           "   RestartScan          : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), FileHandle, Event, ApcRoutine, ApcContext, IoStatusBlock,
           FileInformation, Length, FileInformationClass, FileMask,
           (FileMask != 0) ? FileMask->Buffer : "", RestartScan);

    NTSTATUS ret;

    if(FileInformationClass != 1)   // Due to unicode->string conversion
        CxbxKrnlCleanup("Unsupported FileInformationClass");

    NtDll::UNICODE_STRING NtFileMask;

    wchar_t wszObjectName[160];

    // initialize FileMask
    {
        if(FileMask != 0)
            mbstowcs(wszObjectName, FileMask->Buffer, 160);
        else
            mbstowcs(wszObjectName, "", 160);

        NtDll::RtlInitUnicodeString(&NtFileMask, wszObjectName);
    }

    NtDll::FILE_DIRECTORY_INFORMATION *FileDirInfo = (NtDll::FILE_DIRECTORY_INFORMATION*)CxbxMalloc(0x40 + 160*2);

    char    *mbstr = FileInformation->FileName;
    wchar_t *wcstr = FileDirInfo->FileName;

    do
    {
        ZeroMemory(wcstr, 160*2);

        ret = NtDll::NtQueryDirectoryFile
        (
            FileHandle, Event, (NtDll::PIO_APC_ROUTINE)ApcRoutine, ApcContext, (NtDll::IO_STATUS_BLOCK*)IoStatusBlock, FileDirInfo,
            0x40+160*2, (NtDll::FILE_INFORMATION_CLASS)FileInformationClass, TRUE, &NtFileMask, RestartScan
        );

        // convert from PC to Xbox
        {
            memcpy(FileInformation, FileDirInfo, 0x40);

            wcstombs(mbstr, wcstr, 160);

            FileInformation->FileNameLength /= 2;
        }

        RestartScan = FALSE;
    }
    // Xbox does not return . and ..
    while(strcmp(mbstr, ".") == 0 || strcmp(mbstr, "..") == 0);

    // TODO: Cache the last search result for quicker access with CreateFile (xbox does this internally!)
    CxbxFree(FileDirInfo);

    EmuSwapFS();   // Xbox FS

    return ret;
}

// ******************************************************************
// * 0x00D2 - NtQueryFullAttributesFile
// ******************************************************************
XBSYSAPI EXPORTNUM(210) xboxkrnl::NTSTATUS NTAPI xboxkrnl::NtQueryFullAttributesFile
(
    IN  POBJECT_ATTRIBUTES          ObjectAttributes,
    OUT PVOID                       Attributes
)
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): NtQueryFullAttributesFile\n"
           "(\n"
           "   ObjectAttributes    : 0x%.08X (%s)\n"
           "   Attributes          : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), ObjectAttributes, ObjectAttributes->ObjectName->Buffer, Attributes);

//	__asm int 3;

    char *szBuffer = ObjectAttributes->ObjectName->Buffer;

    wchar_t wszObjectName[160];

    NtDll::UNICODE_STRING    NtUnicodeString;
    NtDll::OBJECT_ATTRIBUTES NtObjAttr;

	// Ensure that we are in the current directory for D:\\.
	// TODO: Other directories when needed.
	if((szBuffer[0] == 'D' || szBuffer[0] == 'd') && szBuffer[1] == ':' || szBuffer[2] == '\\')
	{
		szBuffer += 3;

		 DbgPrintf("EmuXapi (0x%X): NtQueryFullAttributesFile Corrected path...\n", GetCurrentThreadId());
         DbgPrintf("  Org:\"%s\"\n", ObjectAttributes->ObjectName->Buffer);
         DbgPrintf("  New:\"$XbePath\\%s\"\n", szBuffer);
    }

    // initialize object attributes
    {
        mbstowcs(wszObjectName, szBuffer, 160);

        NtDll::RtlInitUnicodeString(&NtUnicodeString, wszObjectName);

        InitializeObjectAttributes(&NtObjAttr, &NtUnicodeString, ObjectAttributes->Attributes, ObjectAttributes->RootDirectory, NULL);
    }

    NTSTATUS ret = NtDll::NtQueryFullAttributesFile(&NtObjAttr, Attributes);

	if(FAILED(ret))
		EmuWarning("NtQueryFullAttributesFile failed! (0x%.08X)\n", ret);

    EmuSwapFS();   // Xbox FS

    return ret;
}

// ******************************************************************
// * 0x00D3 - NtQueryInformationFile
// ******************************************************************
XBSYSAPI EXPORTNUM(211) xboxkrnl::NTSTATUS NTAPI xboxkrnl::NtQueryInformationFile
(
    IN  HANDLE                      FileHandle,
    OUT PIO_STATUS_BLOCK            IoStatusBlock,
    OUT PVOID                       FileInformation,
    IN  ULONG                       Length,
    IN  FILE_INFORMATION_CLASS      FileInfo
)
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): NtQueryInformationFile\n"
           "(\n"
           "   FileHandle          : 0x%.08X\n"
           "   IoStatusBlock       : 0x%.08X\n"
           "   FileInformation     : 0x%.08X\n"
           "   Length              : 0x%.08X\n"
           "   FileInformationClass: 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), FileHandle, IoStatusBlock, FileInformation,
           Length, FileInfo);

	// TODO: IIRC, this function is depreciated.  Maybe we should just use
	// ZwQueryInformationFile instead?

//    if(FileInfo != FilePositionInformation && FileInfo != FileNetworkOpenInformation)
//        CxbxKrnlCleanup("Unknown FILE_INFORMATION_CLASS 0x%.08X", FileInfo);

    NTSTATUS ret = NtDll::NtQueryInformationFile
    (
        FileHandle,
        (NtDll::PIO_STATUS_BLOCK)IoStatusBlock,
        (NtDll::PFILE_FS_SIZE_INFORMATION)FileInformation,
        Length,
        (NtDll::FILE_INFORMATION_CLASS)FileInfo
    );

    //
    // DEBUGGING!
    //
    {
        /*
        _asm int 3;
        NtDll::FILE_NETWORK_OPEN_INFORMATION *pInfo = (NtDll::FILE_NETWORK_OPEN_INFORMATION*)FileInformation;

        if(FileInfo == FileNetworkOpenInformation && (pInfo->AllocationSize.LowPart == 57344))
        {
            DbgPrintf("pInfo->AllocationSize : %d\n", pInfo->AllocationSize.LowPart);
            DbgPrintf("pInfo->EndOfFile      : %d\n", pInfo->EndOfFile.LowPart);

            pInfo->EndOfFile.LowPart = 0x1000;
            pInfo->AllocationSize.LowPart = 0x1000;

            fflush(stdout);
        }
        */
    }

    if(FAILED(ret))
        EmuWarning("NtQueryInformationFile failed! (0x%.08X)", ret);

    EmuSwapFS();   // Xbox FS

    return ret;
}

// ******************************************************************
// * 0x00D9 - NtQueryVirtualMemory
// ******************************************************************
XBSYSAPI EXPORTNUM(217) xboxkrnl::NTSTATUS NTAPI xboxkrnl::NtQueryVirtualMemory
(
    IN  PVOID                       BaseAddress,
    OUT PMEMORY_BASIC_INFORMATION   Buffer
)
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): NtQueryVirtualMemory\n"
           "(\n"
           "   BaseAddress         : 0x%.08X\n"
           "   Buffer              : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), BaseAddress, Buffer);

    NTSTATUS ret = NtDll::NtQueryVirtualMemory
    (
        GetCurrentProcess(),
        BaseAddress,
        (NtDll::MEMORY_INFORMATION_CLASS)NtDll::MemoryBasicInformation,
        (NtDll::PMEMORY_BASIC_INFORMATION)Buffer,
        sizeof(MEMORY_BASIC_INFORMATION),
        0
    );

    if(FAILED(ret)) {
        EmuWarning("NtQueryVirtualMemory failed (%s)!", NtStatusToString(ret));

        // Bugfix for "Forza Motorsport", which iterates over 2 Gb of memory in 64kb chunks,
        // but fails on this last query. It's not done though, as after this Forza tries to
        // NtAllocateVirtualMemory at address 0x00000000 (3 times, actually) which fails too...
        //
        // Ported back from dxbx, translator PatrickvL
        
        if (BaseAddress == (PVOID)0x7FFF0000) {
            Buffer->BaseAddress = BaseAddress;
            Buffer->AllocationBase = BaseAddress;
            Buffer->AllocationProtect = PAGE_READONLY;
            Buffer->RegionSize = 64 * 1024;             // size, in bytes, of the region beginning at the base address in which all pages have identical attributes
            Buffer->State = 4096;                       // MEM_DECOMMIT | PAGE_EXECUTE_WRITECOPY etc
            Buffer->Protect = PAGE_READONLY;            // One of the flags listed for the AllocationProtect member is specified
            Buffer->Type = 262144;                      // Specifies the type of pages in the region. (MEM_IMAGE, MEM_MAPPED or MEM_PRIVATE)

            ret = STATUS_SUCCESS;

            DbgPrintf("EmuKrnl (0x%X): NtQueryVirtualMemory: Applied fix for Forza Motorsport!\n", GetCurrentThreadId());
        }
    }

    EmuSwapFS();   // Xbox FS

    return ret;
}

// ******************************************************************
// * 0x00DA - NtQueryVolumeInformationFile
// ******************************************************************
XBSYSAPI EXPORTNUM(218) xboxkrnl::NTSTATUS NTAPI xboxkrnl::NtQueryVolumeInformationFile
(
    IN  HANDLE                      FileHandle,
    OUT PIO_STATUS_BLOCK            IoStatusBlock,
    OUT PFILE_FS_SIZE_INFORMATION   FileInformation,
    IN  ULONG                       Length,
    IN  FS_INFORMATION_CLASS        FileInformationClass
)
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): NtQueryVolumeInformationFile\n"
           "(\n"
           "   FileHandle          : 0x%.08X\n"
           "   IoStatusBlock       : 0x%.08X\n"
           "   FileInformation     : 0x%.08X\n"
           "   Length              : 0x%.08X\n"
           "   FileInformationClass: 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), FileHandle, IoStatusBlock, FileInformation,
           Length, FileInformationClass);

    // Safety/Sanity Check
    if(FileInformationClass != FileFsSizeInformation)
        CxbxKrnlCleanup("NtQueryVolumeInformationFile: Unsupported FileInformationClass");

    NTSTATUS ret = NtDll::NtQueryVolumeInformationFile
    (
        FileHandle,
        (NtDll::PIO_STATUS_BLOCK)IoStatusBlock,
        (NtDll::PFILE_FS_SIZE_INFORMATION)FileInformation, Length,
        (NtDll::FS_INFORMATION_CLASS)FileInformationClass
    );

    // NOTE: TODO: Dynamically fill in, or allow configuration?
    if(FileInformationClass == FileFsSizeInformation)
    {
        FILE_FS_SIZE_INFORMATION *SizeInfo = (FILE_FS_SIZE_INFORMATION*)FileInformation;

        SizeInfo->TotalAllocationUnits.QuadPart     = 0x4C468;
        SizeInfo->AvailableAllocationUnits.QuadPart = 0x2F125;
        SizeInfo->SectorsPerAllocationUnit          = 32;
        SizeInfo->BytesPerSector                    = 512;
    }

    EmuSwapFS();   // Xbox FS

    return ret;
}

// ******************************************************************
// * 0x00DA - NtReadFile
// ******************************************************************
XBSYSAPI EXPORTNUM(219) xboxkrnl::NTSTATUS NTAPI xboxkrnl::NtReadFile
(
    IN  HANDLE          FileHandle,            // TODO: correct paramters
    IN  HANDLE          Event OPTIONAL,
    IN  PVOID           ApcRoutine OPTIONAL,
    IN  PVOID           ApcContext,
    OUT PVOID           IoStatusBlock,
    OUT PVOID           Buffer,
    IN  ULONG           Length,
    IN  PLARGE_INTEGER  ByteOffset OPTIONAL
)
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): NtReadFile\n"
           "(\n"
           "   FileHandle          : 0x%.08X\n"
           "   Event               : 0x%.08X\n"
           "   ApcRoutine          : 0x%.08X\n"
           "   ApcContext          : 0x%.08X\n"
           "   IoStatusBlock       : 0x%.08X\n"
           "   Buffer              : 0x%.08X\n"
           "   Length              : 0x%.08X\n"
           "   ByteOffset          : 0x%.08X (0x%.08X)\n"
           ");\n",
           GetCurrentThreadId(), FileHandle, Event, ApcRoutine,
           ApcContext, IoStatusBlock, Buffer, Length, ByteOffset, ByteOffset == 0 ? 0 : ByteOffset->QuadPart);

// Halo...
//    if(ByteOffset != 0 && ByteOffset->QuadPart == 0x00120800)
//        _asm int 3

    NTSTATUS ret = NtDll::NtReadFile(FileHandle, Event, ApcRoutine, ApcContext, IoStatusBlock, Buffer, Length, (NtDll::LARGE_INTEGER*)ByteOffset, 0);

    if(FAILED(ret))
		EmuWarning("NtReadFile Failed! (0x%.08X)", ret);

    EmuSwapFS();   // Xbox FS

    return ret;
}

// ******************************************************************
// * 0x00DD - NtReleaseMutant
// ******************************************************************
XBSYSAPI EXPORTNUM(221) xboxkrnl::NTSTATUS NTAPI xboxkrnl::NtReleaseMutant
(
    IN  HANDLE  MutantHandle,
    OUT PLONG   PreviousCount
)
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): NtReleaseMutant\n"
           "(\n"
           "   MutantHandle         : 0x%.08X\n"
           "   PreviousCount        : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), MutantHandle, PreviousCount);

    // redirect to NtCreateMutant
    NTSTATUS ret = NtDll::NtReleaseMutant(MutantHandle, PreviousCount);

    if(FAILED(ret))
        EmuWarning("NtReleaseMutant Failed!");

    EmuSwapFS();   // Xbox FS

    return STATUS_SUCCESS;
}

// ******************************************************************
// * 0x00DE - NtReleaseSemaphore
// ******************************************************************
XBSYSAPI EXPORTNUM(222) xboxkrnl::NTSTATUS NTAPI xboxkrnl::NtReleaseSemaphore
(
    IN  HANDLE              SemaphoreHandle,
    IN  ULONG               ReleaseCount,
    OUT PULONG              PreviousCount
)
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): NtReleaseSemaphore\n"
           "(\n"
           "   SemaphoreHandle      : 0x%.08X\n"
           "   ReleaseCount         : 0x%.08X\n"
           "   PreviousCount        : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), SemaphoreHandle, ReleaseCount, PreviousCount);

    NTSTATUS ret = NtDll::NtReleaseSemaphore(SemaphoreHandle, ReleaseCount, PreviousCount);

    if(FAILED(ret))
        EmuWarning("NtReleaseSemaphore failed!");

    EmuSwapFS();   // Xbox FS

    return ret;
}

// ******************************************************************
// * 0x00E0 - NtResumeThread
// ******************************************************************
XBSYSAPI EXPORTNUM(224) xboxkrnl::NTSTATUS NTAPI xboxkrnl::NtResumeThread
(
    IN  HANDLE ThreadHandle,
    OUT PULONG PreviousSuspendCount
)
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): NtResumeThread\n"
           "(\n"
           "   ThreadHandle         : 0x%.08X\n"
           "   PreviousSuspendCount : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), ThreadHandle, PreviousSuspendCount);

    NTSTATUS ret = NtDll::NtResumeThread(ThreadHandle, PreviousSuspendCount);

    Sleep(10);

    EmuSwapFS();   // Xbox FS

    return ret;
}

// ******************************************************************
// * 0x00E1 - NtSetEvent
// ******************************************************************
XBSYSAPI EXPORTNUM(225) xboxkrnl::NTSTATUS NTAPI xboxkrnl::NtSetEvent
(
    IN  HANDLE EventHandle,
    OUT PLONG  PreviousState
)
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): NtSetEvent\n"
           "(\n"
           "   EventHandle          : 0x%.08X\n"
           "   PreviousState        : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), EventHandle, PreviousState);

    NTSTATUS ret = NtDll::NtSetEvent(EventHandle, PreviousState);

    if(FAILED(ret))
        EmuWarning("NtSetEvent Failed!");

    EmuSwapFS();   // Xbox FS

    return ret;
}

// ******************************************************************
// * 0x00E2 - NtSetInformationFile
// ******************************************************************
XBSYSAPI EXPORTNUM(226) xboxkrnl::NTSTATUS NTAPI xboxkrnl::NtSetInformationFile
(
    IN  HANDLE  FileHandle,            // TODO: correct paramters
    OUT PVOID   IoStatusBlock,
    IN  PVOID   FileInformation,
    IN  ULONG   Length,
    IN  ULONG   FileInformationClass
)
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): NtSetInformationFile\n"
           "(\n"
           "   FileHandle           : 0x%.08X\n"
           "   IoStatusBlock        : 0x%.08X\n"
           "   FileInformation      : 0x%.08X\n"
           "   Length               : 0x%.08X\n"
           "   FileInformationClass : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), FileHandle, IoStatusBlock, FileInformation,
           Length, FileInformationClass);

    NTSTATUS ret = NtDll::NtSetInformationFile(FileHandle, IoStatusBlock, FileInformation, Length, FileInformationClass);

    EmuSwapFS();   // Xbox FS

    return ret;
}

// ******************************************************************
// * 0x00E4 - NtSetSystemTime
// ******************************************************************
XBSYSAPI EXPORTNUM(228) xboxkrnl::NTSTATUS NTAPI xboxkrnl::NtSetSystemTime
(
	IN  PLARGE_INTEGER			SystemTime,
	OUT PLARGE_INTEGER			PreviousTime OPTIONAL 
)
{
	EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): NtSetInformationFile\n"
           "(\n"
           "   SystemTime           : 0x%.08X\n"
           "   PreviousTime         : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), SystemTime, PreviousTime);

	// Maybe it's not such a good idea to allow Cxbx to change your time 
	// clock.  Might need admin privileges to do this.... dunno.

    NTSTATUS ret = STATUS_SUCCESS;

    EmuSwapFS();   // Xbox FS

    return ret;
}

// ******************************************************************
// * 0x00E7 - NtSuspendThread
// ******************************************************************
XBSYSAPI EXPORTNUM(231) xboxkrnl::NTSTATUS NTAPI xboxkrnl::NtSuspendThread
(
    IN  HANDLE  ThreadHandle,
    OUT PULONG  PreviousSuspendCount OPTIONAL
)
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): NtSuspendThread\n"
           "(\n"
           "   ThreadHandle         : 0x%.08X\n"
           "   PreviousSuspendCount : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), ThreadHandle, PreviousSuspendCount);

    NTSTATUS ret = NtDll::NtSuspendThread(ThreadHandle, PreviousSuspendCount);

    EmuSwapFS();   // Xbox FS

    return ret;
}

// ******************************************************************
// * 0x00E8 - NtUserIoApcDispatcher
// ******************************************************************
XBSYSAPI EXPORTNUM(232) VOID NTAPI xboxkrnl::NtUserIoApcDispatcher
(
    PVOID            ApcContext,
    PIO_STATUS_BLOCK IoStatusBlock,
    ULONG            Reserved
)
{
    // Note: This function is called within Win2k/XP context, so no EmuSwapFS here

    DbgPrintf("EmuKrnl (0x%X): NtUserIoApcDispatcher\n"
           "(\n"
           "   ApcContext           : 0x%.08X\n"
           "   IoStatusBlock        : 0x%.08X\n"
           "   Reserved             : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), ApcContext, IoStatusBlock, Reserved);

    DbgPrintf("IoStatusBlock->Pointer     : 0x%.08X\n"
              "IoStatusBlock->Information : 0x%.08X\n", IoStatusBlock->u1.Pointer, IoStatusBlock->Information);

    EmuSwapFS();   // Xbox FS

    uint32 dwEsi, dwEax, dwEcx;

    dwEsi = (uint32)IoStatusBlock;

    if((IoStatusBlock->u1.Status & 0xC0000000) == 0xC0000000)
    {
        dwEcx = 0;
        dwEax = NtDll::RtlNtStatusToDosError(IoStatusBlock->u1.Status);
    }
    else
    {
        dwEcx = (DWORD)IoStatusBlock->Information;
        dwEax = 0;
    }

    /*
    // ~XDK 3911??
    if(true)
    {
        dwEsi = dw2;
        dwEcx = dw1;
        dwEax = dw3;

    }
    else
    {
        dwEsi = dw1;
        dwEcx = dw2;
        dwEax = dw3;
    }//*/

    __asm
    {
        pushad
        /*
        mov esi, IoStatusBlock
        mov ecx, dwEcx
        mov eax, dwEax
        */
        // TODO: Figure out if/why this works!? Matches prototype, but not xboxkrnl disassembly
        // Seems to be XDK/version dependand??
        mov esi, dwEsi
        mov ecx, dwEcx
        mov eax, dwEax

        push esi
        push ecx
        push eax

        call ApcContext

        popad
    }

    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): NtUserIoApcDispatcher Completed\n", GetCurrentThreadId());

    return;
}

// ******************************************************************
// * 0x00EA - NtWaitForSingleObjectEx
// ******************************************************************
XBSYSAPI EXPORTNUM(234) xboxkrnl::NTSTATUS NTAPI xboxkrnl::NtWaitForSingleObjectEx
(
    IN  HANDLE          Handle,
    IN  CHAR            WaitMode,
    IN  BOOLEAN         Alertable,
    IN  PLARGE_INTEGER  Timeout
)
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): NtWaitForSingleObjectEx\n"
           "(\n"
           "   Handle               : 0x%.08X\n"
           "   WaitMode             : 0x%.08X\n"
           "   Alertable            : 0x%.08X\n"
           "   Timeout              : 0x%.08X (%d)\n"
           ");\n",
           GetCurrentThreadId(), Handle, WaitMode, Alertable, Timeout, Timeout == 0 ? 0 : Timeout->QuadPart);

    NTSTATUS ret = NtDll::NtWaitForSingleObject(Handle, Alertable, (NtDll::PLARGE_INTEGER)Timeout);

    DbgPrintf("Finished waiting for 0x%.08X\n", Handle);

    EmuSwapFS();   // Xbox FS

    return ret;
}

// ******************************************************************
// * NtWaitForMultipleObjectsEx
// ******************************************************************
XBSYSAPI EXPORTNUM(235) xboxkrnl::NTSTATUS NTAPI xboxkrnl::NtWaitForMultipleObjectsEx
(
    IN  ULONG           Count,
    IN  HANDLE         *Handles,
    IN  WAIT_TYPE       WaitType,
    IN  CHAR            WaitMode,
    IN  BOOLEAN         Alertable,
    IN  PLARGE_INTEGER  Timeout
)
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): NtWaitForMultipleObjectsEx\n"
           "(\n"
           "   Count                : 0x%.08X\n"
           "   Handles              : 0x%.08X\n"
           "   WaitType             : 0x%.08X\n"
           "   WaitMode             : 0x%.08X\n"
           "   Alertable            : 0x%.08X\n"
           "   Timeout              : 0x%.08X (%d)\n"
           ");\n",
           GetCurrentThreadId(), Count, Handles, WaitType, WaitMode, Alertable,
           Timeout, Timeout == 0 ? 0 : Timeout->QuadPart);

    NTSTATUS ret = NtDll::NtWaitForMultipleObjects(Count, Handles, (NtDll::OBJECT_WAIT_TYPE)WaitType, Alertable, (NtDll::PLARGE_INTEGER)Timeout);

    EmuSwapFS();   // Xbox FS

    return ret;
}

// ******************************************************************
// * 0x00EC - NtWriteFile
// ******************************************************************
XBSYSAPI EXPORTNUM(236) xboxkrnl::NTSTATUS NTAPI xboxkrnl::NtWriteFile
(
    IN  HANDLE          FileHandle,            // TODO: correct paramters
    IN  PVOID           Event,
    IN  PVOID           ApcRoutine,
    IN  PVOID           ApcContext,
    OUT PVOID           IoStatusBlock,
    IN  PVOID           Buffer,
    IN  ULONG           Length,
    IN  PLARGE_INTEGER  ByteOffset
)
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): NtWriteFile\n"
           "(\n"
           "   FileHandle          : 0x%.08X\n"
           "   Event               : 0x%.08X\n"
           "   ApcRoutine          : 0x%.08X\n"
           "   ApcContext          : 0x%.08X\n"
           "   IoStatusBlock       : 0x%.08X\n"
           "   Buffer              : 0x%.08X\n"
           "   Length              : 0x%.08X\n"
           "   ByteOffset          : 0x%.08X (0x%.08X)\n"
           ");\n",
           GetCurrentThreadId(), FileHandle, Event, ApcRoutine,
           ApcContext, IoStatusBlock, Buffer, Length, ByteOffset, ByteOffset == 0 ? 0 : ByteOffset->QuadPart);

// Halo..
//    if(ByteOffset != 0 && ByteOffset->QuadPart == 0x01C00800)
//        _asm int 3

    NTSTATUS ret = NtDll::NtWriteFile(FileHandle, Event, ApcRoutine, ApcContext, IoStatusBlock, Buffer, Length, (NtDll::LARGE_INTEGER*)ByteOffset, 0);

    if(FAILED(ret))
        EmuWarning("NtWriteFile Failed! (0x%.08X)", ret);

    EmuSwapFS();   // Xbox FS

    return ret;
}

// ******************************************************************
// * 0x00EE - NtYieldExecution
// ******************************************************************
XBSYSAPI EXPORTNUM(238) VOID NTAPI xboxkrnl::NtYieldExecution()
{
    EmuSwapFS();   // Win2k/XP FS

    // NOTE: this eats up the debug log far too quickly
    //DbgPrintf("EmuKrnl (0x%X): NtYieldExecution();\n", GetCurrentThreadId());

    NtDll::NtYieldExecution();

    EmuSwapFS();   // Xbox FS

    return;
}

// ******************************************************************
// * 0x00FF - PsCreateSystemThreadEx
// ******************************************************************
XBSYSAPI EXPORTNUM(255) xboxkrnl::NTSTATUS NTAPI xboxkrnl::PsCreateSystemThreadEx
(
    OUT PHANDLE         ThreadHandle,
    IN  ULONG           ThreadExtraSize,
    IN  ULONG           KernelStackSize,
    IN  ULONG           TlsDataSize,
    OUT PULONG          ThreadId OPTIONAL,
    IN  PVOID           StartContext1,
    IN  PVOID           StartContext2,
    IN  BOOLEAN         CreateSuspended,
    IN  BOOLEAN         DebugStack,
    IN  PKSTART_ROUTINE StartRoutine
)
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): PsCreateSystemThreadEx\n"
           "(\n"
           "   ThreadHandle        : 0x%.08X\n"
           "   ThreadExtraSize     : 0x%.08X\n"
           "   KernelStackSize     : 0x%.08X\n"
           "   TlsDataSize         : 0x%.08X\n"
           "   ThreadId            : 0x%.08X\n"
           "   StartContext1       : 0x%.08X\n"
           "   StartContext2       : 0x%.08X\n"
           "   CreateSuspended     : 0x%.08X\n"
           "   DebugStack          : 0x%.08X\n"
           "   StartRoutine        : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), ThreadHandle, ThreadExtraSize, KernelStackSize, TlsDataSize, ThreadId,
           StartContext1, StartContext2, CreateSuspended, DebugStack, StartRoutine);

	static bool bFirstTime = false;

    // create thread, using our special proxy technique
    {
        DWORD dwThreadId;

        // PCSTProxy is responsible for cleaning up this pointer
        ::PCSTProxyParam *iPCSTProxyParam = new ::PCSTProxyParam();

        iPCSTProxyParam->StartContext1 = StartContext1;
        iPCSTProxyParam->StartContext2 = StartContext2;
        iPCSTProxyParam->StartRoutine  = StartRoutine;
        iPCSTProxyParam->StartSuspended = CreateSuspended;
        iPCSTProxyParam->hStartedEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

        *ThreadHandle = (HANDLE)_beginthreadex(NULL, NULL, PCSTProxy, iPCSTProxyParam, NULL, (uint*)&dwThreadId);

        WaitForSingleObject(iPCSTProxyParam->hStartedEvent, 1000);

//        *ThreadHandle = CreateThread(NULL, NULL, PCSTProxy, iPCSTProxyParam, NULL, &dwThreadId);

        DbgPrintf("EmuKrnl (0x%X): ThreadHandle : 0x%X, ThreadId : 0x%.08X\n", GetCurrentThreadId(), *ThreadHandle, dwThreadId);

        // we must duplicate this handle in order to retain Suspend/Resume thread rights from a remote thread
        {
            HANDLE hDupHandle = NULL;

            DuplicateHandle(GetCurrentProcess(), *ThreadHandle, GetCurrentProcess(), &hDupHandle, 0, FALSE, DUPLICATE_SAME_ACCESS);

            CxbxKrnlRegisterThread(hDupHandle);
        }

        if(ThreadId != NULL)
            *ThreadId = dwThreadId;
    }

    EmuSwapFS();   // Xbox FS

    return STATUS_SUCCESS;
}

// ******************************************************************
// * 0x0102 - PsTerminateSystemThread
// ******************************************************************
XBSYSAPI EXPORTNUM(258) VOID NTAPI xboxkrnl::PsTerminateSystemThread(IN NTSTATUS ExitStatus)
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): PsTerminateSystemThread\n"
           "(\n"
           "   ExitStatus          : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), ExitStatus);

    // call thread notification routine(s)
    if(g_iThreadNotificationCount != 0)
    {
		for(int i = 0; i < 16; i++ )
		{
			XTL::XTHREAD_NOTIFY_PROC pfnNotificationRoutine = (XTL::XTHREAD_NOTIFY_PROC)g_pfnThreadNotification[i];

			// If the routine doesn't exist, don't execute it!
			if(pfnNotificationRoutine == NULL)
				continue;

			DbgPrintf("EmuKrnl (0x%X): Calling pfnNotificationRoutine[%d] (0x%.08X)\n", g_iThreadNotificationCount, GetCurrentThreadId(), pfnNotificationRoutine);

			EmuSwapFS();   // Xbox FS

			pfnNotificationRoutine(FALSE);

			EmuSwapFS();   // Win2k/XP FS
		}
    }

//    CxbxKrnlTerminateThread();

    EmuCleanupFS();

    _endthreadex(ExitStatus);
    //ExitThread(ExitStatus);

    return;
}

// ******************************************************************
// * 0x0104 - RtlAnsiStringToUnicodeString
// ******************************************************************
XBSYSAPI EXPORTNUM(260) xboxkrnl::NTSTATUS NTAPI xboxkrnl::RtlAnsiStringToUnicodeString
(
    PUNICODE_STRING DestinationString,
    PSTRING         SourceString,
    UCHAR           AllocateDestinationString
)
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): RtlAnsiStringToUnicodeString\n"
           "(\n"
           "   DestinationString         : 0x%.08X\n"
           "   SourceString              : 0x%.08X\n"
           "   AllocateDestinationString : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), DestinationString, SourceString, AllocateDestinationString);

    NTSTATUS ret = NtDll::RtlAnsiStringToUnicodeString((NtDll::UNICODE_STRING*)DestinationString, (NtDll::STRING*)SourceString, AllocateDestinationString);

    EmuSwapFS();   // Xbox FS

    return ret;
}
// ******************************************************************
// * 0x0108 - RtlAssert - Debug API?
// ******************************************************************
XBSYSAPI EXPORTNUM(264) VOID NTAPI xboxkrnl::RtlAssert
(
    PVOID   FailedAssertion,
    PVOID   FileName,
    ULONG   LineNumber,
    PCHAR   Message
)
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): RtlAssert\n"
           "(\n"
           "   FailedAssertion           : 0x%.08X (\"%s\")\n"
           "   FileName                  : 0x%.08X (\"%s\")\n"
           "   LineNumber                : 0x%.08X (\"%lu\")\n"
           "   Message                   : 0x%.08X (\"%s\")\n"
           ");\n",
           GetCurrentThreadId(), FailedAssertion, FailedAssertion, FileName, FileName, LineNumber, LineNumber, Message, Message);

    CxbxKrnlCleanup("RtlAssert() raised by emulated program - consult Debug log");

    EmuSwapFS();   // Xbox FS

    return;
}

// ******************************************************************
// * 0x0115 RtlEnterCriticalSection
// ******************************************************************
XBSYSAPI EXPORTNUM(277) VOID NTAPI xboxkrnl::RtlEnterCriticalSection
(
  IN PRTL_CRITICAL_SECTION CriticalSection
)
{
    EmuSwapFS();   // Win2k/XP FS

    /** sorta pointless
    DbgPrintf("EmuKrnl (0x%X): RtlEnterCriticalSection\n"
           "(\n"
           "   CriticalSection     : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), CriticalSection);
    //*/

    //printf("CriticalSection->LockCount : %d\n", CriticalSection->LockCount);

	// This seems redundant, but xbox software doesn't always do it
	if (CriticalSection)
	{
		int iSection = FindCriticalSection(CriticalSection);

		if (iSection >= 0)
		{
			GlobalCriticalSections[iSection].XboxCriticalSection = CriticalSection;
			if (CriticalSection->LockCount < 0)
				NtDll::RtlInitializeCriticalSection(&GlobalCriticalSections[iSection].NativeCriticalSection);

			NtDll::RtlEnterCriticalSection(&GlobalCriticalSections[iSection].NativeCriticalSection);

			CriticalSection->LockCount = GlobalCriticalSections[iSection].NativeCriticalSection.LockCount;
			CriticalSection->RecursionCount = GlobalCriticalSections[iSection].NativeCriticalSection.RecursionCount;
			CriticalSection->OwningThread = GlobalCriticalSections[iSection].NativeCriticalSection.OwningThread;
		}
		//if(CriticalSection->LockCount == -1)
			//NtDll::RtlInitializeCriticalSection((NtDll::_RTL_CRITICAL_SECTION*)CriticalSection);

		//NtDll::RtlEnterCriticalSection((NtDll::_RTL_CRITICAL_SECTION*)CriticalSection);
	}

    EmuSwapFS();   // Xbox FS

    return;
}

// ******************************************************************
// * 0x0117 - RtlEqualString
// ******************************************************************
XBSYSAPI EXPORTNUM(279) xboxkrnl::BOOLEAN NTAPI xboxkrnl::RtlEqualString
(
  IN PSTRING String1,
  IN PSTRING String2,
  IN BOOLEAN CaseSensitive
)
{
	EmuSwapFS();	// Win2k/XP FS

	DbgPrintf("EmuKrnl (0x%X): RtlEqualString\n"
			"(\n"
			"	String1            : 0x%.08X (\"%s\")\n"
			"	String2            : 0x%.08X (\"%s\")\n"
			"	CaseSensitive      : 0x%.08X\n"
			");\n",
			GetCurrentThreadId(), String1, String1, String2, String2, CaseSensitive );

	BOOLEAN bRet = NtDll::RtlEqualString( (NtDll::PSTRING)String1, (NtDll::PSTRING)String2, (NtDll::BOOLEAN)CaseSensitive );

	EmuSwapFS();	// Xbox FS

	return bRet;
}

// ******************************************************************
// * 0x0121 - RtlInitAnsiString
// ******************************************************************
XBSYSAPI EXPORTNUM(289) VOID NTAPI xboxkrnl::RtlInitAnsiString
(
  IN OUT PANSI_STRING DestinationString,
  IN     PCSZ         SourceString
)
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): RtlInitAnsiString\n"
           "(\n"
           "   DestinationString   : 0x%.08X\n"
           "   SourceString        : 0x%.08X (\"%s\")\n"
           ");\n",
           GetCurrentThreadId(), DestinationString, SourceString, SourceString);

    NtDll::RtlInitAnsiString((NtDll::PANSI_STRING)DestinationString, (NtDll::PCSZ)SourceString);

    EmuSwapFS();   // Xbox FS

    return;
}

// ******************************************************************
// * 0x0122 - RtlInitUnicodeString
// ******************************************************************
XBSYSAPI EXPORTNUM(290) VOID NTAPI xboxkrnl::RtlInitUnicodeString
(
  IN OUT PUNICODE_STRING DestinationString,
  IN     PSTRING         SourceString
)
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): RtlInitUnicodeString\n"
           "(\n"
           "   DestinationString   : 0x%.08X\n"
           "   SourceString        : 0x%.08X (\"%ls\")\n"
           ");\n",
           GetCurrentThreadId(), DestinationString, SourceString, SourceString);

    NtDll::RtlInitUnicodeString((NtDll::PUNICODE_STRING)DestinationString, (NtDll::PCWSTR)SourceString);

    EmuSwapFS();   // Xbox FS

    return;
}

// ******************************************************************
// * 0x0123 - RtlInitializeCriticalSection
// ******************************************************************
XBSYSAPI EXPORTNUM(291) VOID NTAPI xboxkrnl::RtlInitializeCriticalSection
(
  IN PRTL_CRITICAL_SECTION CriticalSection
)
{
    EmuSwapFS();   // Win2k/XP FS

    /*
    DbgPrintf("EmuKrnl (0x%X): RtlInitializeCriticalSection\n"
           "(\n"
           "   CriticalSection     : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), CriticalSection);
    //*/
	int iSection = FindCriticalSection(CriticalSection);

	if (iSection >= 0)
	{
		GlobalCriticalSections[iSection].XboxCriticalSection = CriticalSection;
		NtDll::RtlInitializeCriticalSection(&GlobalCriticalSections[iSection].NativeCriticalSection);

		CriticalSection->LockCount = GlobalCriticalSections[iSection].NativeCriticalSection.LockCount;
		CriticalSection->RecursionCount = GlobalCriticalSections[iSection].NativeCriticalSection.RecursionCount;
		CriticalSection->OwningThread = GlobalCriticalSections[iSection].NativeCriticalSection.OwningThread;
	}
	//NtDll::RtlInitializeCriticalSection((NtDll::_RTL_CRITICAL_SECTION*)CriticalSection);

    EmuSwapFS();   // Xbox FS

    return;
}

// ******************************************************************
// * 0x0126 RtlEnterCriticalSection
// ******************************************************************
XBSYSAPI EXPORTNUM(294) VOID NTAPI xboxkrnl::RtlLeaveCriticalSection
(
  IN PRTL_CRITICAL_SECTION CriticalSection
)
{
    EmuSwapFS();   // Win2k/XP FS

	int iSection = FindCriticalSection(CriticalSection);

	if (iSection >= 0)
	{
		GlobalCriticalSections[iSection].XboxCriticalSection = CriticalSection;
		NtDll::RtlLeaveCriticalSection(&GlobalCriticalSections[iSection].NativeCriticalSection);

		CriticalSection->LockCount = GlobalCriticalSections[iSection].NativeCriticalSection.LockCount;
		CriticalSection->RecursionCount = GlobalCriticalSections[iSection].NativeCriticalSection.RecursionCount;
		CriticalSection->OwningThread = GlobalCriticalSections[iSection].NativeCriticalSection.OwningThread;
	}
	// Note: We need to execute this before debug output to avoid trouble
	//NtDll::RtlLeaveCriticalSection((NtDll::_RTL_CRITICAL_SECTION*)CriticalSection);

    /* sorta pointless
    DbgPrintf("EmuKrnl (0x%X): RtlLeaveCriticalSection\n"
           "(\n"
           "   CriticalSection     : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), CriticalSection);
    //*/

    EmuSwapFS();   // Xbox FS

    return;
}

// ******************************************************************
// * RtlLowerChar
// ******************************************************************
XBSYSAPI EXPORTNUM(296) xboxkrnl::CHAR NTAPI xboxkrnl::RtlLowerChar(CHAR Character)
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): RtlLowerChar(%c)\n", GetCurrentThreadId(), Character);

    CHAR ret = tolower(Character);

    EmuSwapFS();   // Xbox FS

    return ret;
}

// ******************************************************************
// * 0x012D - RtlNtStatusToDosError
// ******************************************************************
XBSYSAPI EXPORTNUM(301) xboxkrnl::ULONG NTAPI xboxkrnl::RtlNtStatusToDosError
(
    IN NTSTATUS Status
)
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): RtlNtStatusToDosError\n"
           "(\n"
           "   Status              : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), Status);

    ULONG ret = NtDll::RtlNtStatusToDosError(Status);

    EmuSwapFS();   // Xbox FS

    return ret;
}

// ******************************************************************
// * 0x0130 - RtlTimeFieldsToTime
// ******************************************************************
XBSYSAPI EXPORTNUM(304) xboxkrnl::BOOLEAN NTAPI xboxkrnl::RtlTimeFieldsToTime
(
    IN  PTIME_FIELDS    TimeFields,
    OUT PLARGE_INTEGER  Time
)
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): RtlTimeFieldsToTime\n"
           "(\n"
           "   TimeFields          : 0x%.08X\n"
           "   Time                : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), TimeFields, Time);

    BOOLEAN bRet = NtDll::RtlTimeFieldsToTime((NtDll::TIME_FIELDS*)TimeFields, (NtDll::LARGE_INTEGER*)Time);

    EmuSwapFS();   // Xbox FS

    return bRet;
}

// ******************************************************************
// * 0x0131 - RtlTimeToTimeFields
// ******************************************************************
XBSYSAPI EXPORTNUM(305) VOID NTAPI xboxkrnl::RtlTimeToTimeFields
(
    IN  PLARGE_INTEGER  Time,
    OUT PTIME_FIELDS    TimeFields
)
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): RtlTimeToTimeFields\n"
           "(\n"
           "   Time                : 0x%.08X\n"
           "   TimeFields          : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), Time, TimeFields);

    NtDll::RtlTimeToTimeFields((NtDll::LARGE_INTEGER*)Time, (NtDll::TIME_FIELDS*)TimeFields);

    EmuSwapFS();   // Xbox FS

    return;
}

// ******************************************************************
// * RtlTryEnterCriticalSection
// ******************************************************************
XBSYSAPI EXPORTNUM(306) xboxkrnl::BOOLEAN NTAPI xboxkrnl::RtlTryEnterCriticalSection
(
    IN PRTL_CRITICAL_SECTION CriticalSection
)
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): RtlTryEnterCriticalSection\n"
           "(\n"
           "   CriticalSection     : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), CriticalSection);

	BOOL bRet = FALSE;
	
	int iSection = FindCriticalSection(CriticalSection);

	if (iSection >= 0)
	{
		GlobalCriticalSections[iSection].XboxCriticalSection = CriticalSection;
		if (CriticalSection->LockCount < 0)
			NtDll::RtlInitializeCriticalSection(&GlobalCriticalSections[iSection].NativeCriticalSection);

		bRet = NtDll::RtlTryEnterCriticalSection(&GlobalCriticalSections[iSection].NativeCriticalSection);

		CriticalSection->LockCount = GlobalCriticalSections[iSection].NativeCriticalSection.LockCount;
		CriticalSection->RecursionCount = GlobalCriticalSections[iSection].NativeCriticalSection.RecursionCount;
		CriticalSection->OwningThread = GlobalCriticalSections[iSection].NativeCriticalSection.OwningThread;
	}
	//bRet = NtDll::RtlTryEnterCriticalSection((NtDll::PRTL_CRITICAL_SECTION)CriticalSection);

    EmuSwapFS();   // Xbox FS

    return bRet;
}

// ******************************************************************
// * 0x0134 - RtlUnicodeStringToAnsiString
// ******************************************************************
XBSYSAPI EXPORTNUM(308) xboxkrnl::NTSTATUS NTAPI xboxkrnl::RtlUnicodeStringToAnsiString
(
    IN OUT PSTRING         DestinationString,
    IN     PUNICODE_STRING SourceString,
    IN     BOOLEAN         AllocateDestinationString
)
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): RtlUnicodeStringToAnsiString\n"
           "(\n"
           "   DestinationString         : 0x%.08X\n"
           "   SourceString              : 0x%.08X\n"
           "   AllocateDestinationString : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), DestinationString, SourceString, AllocateDestinationString);

    NTSTATUS ret = NtDll::RtlUnicodeStringToAnsiString((NtDll::STRING*)DestinationString, (NtDll::UNICODE_STRING*)SourceString, AllocateDestinationString);

    EmuSwapFS();   // Xbox FS

    return ret;
}

// ******************************************************************
// * 0x0142 - XboxHardwareInfo
// ******************************************************************
XBSYSAPI EXPORTNUM(322) XBOX_HARDWARE_INFO xboxkrnl::XboxHardwareInfo =
{
    0xC0000035,
    0,0,0,0
};

// ******************************************************************
// * 0x0143 - XboxHDKey
// ******************************************************************
XBSYSAPI EXPORTNUM(323) xboxkrnl::UCHAR xboxkrnl::XboxHDKey[16] =
{
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
};

// ******************************************************************
// * XboxSignatureKey
// ******************************************************************
XBSYSAPI EXPORTNUM(325) xboxkrnl::BYTE xboxkrnl::XboxSignatureKey[16] =
{
    // cxbx default saved game key
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// ******************************************************************
// * XcSHAInit
// ******************************************************************
XBSYSAPI EXPORTNUM(335) VOID NTAPI xboxkrnl::XcSHAInit(UCHAR *pbSHAContext)
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): XcSHAInit\n"
           "(\n"
           "   pbSHAContext        : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), pbSHAContext);

    EmuSwapFS();   // Xbox FS

    return;
}

// ******************************************************************
// * XcSHAUpdate
// ******************************************************************
XBSYSAPI EXPORTNUM(336) VOID NTAPI xboxkrnl::XcSHAUpdate(UCHAR *pbSHAContext, UCHAR *pbInput, ULONG dwInputLength)
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): XcSHAUpdate\n"
           "(\n"
           "   pbSHAContext        : 0x%.08X\n"
           "   pbInput             : 0x%.08X\n"
           "   dwInputLength       : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), pbSHAContext, pbInput, dwInputLength);

    EmuSwapFS();   // Xbox FS

    return;
}

// ******************************************************************
// * XcSHAFinal
// ******************************************************************
XBSYSAPI EXPORTNUM(337) VOID NTAPI xboxkrnl::XcSHAFinal(UCHAR *pbSHAContext, UCHAR *pbDigest)
{
    EmuSwapFS();   // Win2k/XP FS

    DbgPrintf("EmuKrnl (0x%X): XcSHAFinal\n"
           "(\n"
           "   pbSHAContext        : 0x%.08X\n"
           "   pbDigest            : 0x%.08X\n"
           ");\n",
           GetCurrentThreadId(), pbSHAContext, pbDigest);

    // for now, we dont care about the digest
    for(int v=0;v<20;v++)
    {
        pbDigest[v] = 0;
    }

    EmuSwapFS();   // Xbox FS

    return;
}

// ******************************************************************
// * HalBootSMCVideoMode
// ******************************************************************
// TODO: Verify this!
XBSYSAPI EXPORTNUM(356) xboxkrnl::DWORD xboxkrnl::HalBootSMCVideoMode = 1;
